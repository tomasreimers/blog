{"/state":{"title":"Chapter 9: State management","data":{"tk-the-problem-with-global-state#TK The problem with global state":"","prop-drilling#Prop drilling":"","architecture#Architecture":"Split data fetch and presentationReact is not MVC","composition#Composition":"","higher-order-components#Higher-order components":"https://legacy.reactjs.org/docs/higher-order-components.html","render-props#Render props":"","tk-context#TK Context":"","tk-external-state-stores#TK External state stores":"Warning, don't use for inputs","tk-derived-state#TK Derived state":"","tk-separation-of-concerns#TK Separation of concerns":"HOCs and Render props"}},"/components":{"title":"Components: The building blocks of UI","data":{"":"As JavaScript became more powerful, the browser transformed from a rendering engine into a sandbox. User expectations kept-up and users demanded more: suddenly, it wasn't an acceptable user experience to refresh the page when a user added something to their shopping cart, or their password and confirm password fields didn't match, web apps were expected to compute and rerender those details client-side.The natural result was increasingly large parts of web pages had to be rendered on the client; however, there was no canonical way to do this. On the server, data was fetched in response to user requests and piped into templates, but the client lived in this awkward in-between where the initial render came from the server, but then subsequent renders and updates had to be constructed on the client.The split source-of-truth between initial render and updates led to predictable problems: HTML fell out-of-sync with data in JavaScript, and rerenders could change the UI in unexpected, and often unintentional, ways.","jsx-html-in-js#JSX: HTML in JS":"It is in this context that JSX was born. Technologically, JSX wasn't that interesting, but as a developer experience improvement, it was genius. JSX flipped the paradigm on its head: JavaScript, not HTML, became the source of truth for all renders (including the initial render). Because that required more HTML to be written in JavaScript than before, JSX introduced a first-class HTML-like syntax embedded within JavaScript: JSX.JSX takes in a DOM element, and mounts a React tree into it using the .render() method. If you're using a higher-level framework (such as Next.js), this is typically handled for you.\nJSX enabled this syntax by adding a build step to transpile the HTML-like syntax into JavaScript functions.Not only could you render HTML inside of JavaScript, but you could also interpolate JavaScript back into HTML using curly braces.","components#Components":"Beyond letting developers write the standard HTML tags, JSX allowed developers to define their own tags, called components, using JavaScript functions (tags native to HTML are called \"primitives\").Like normal functions, these tags evaluate to their return value and take in arguments (called props and passed as attributes to the tag).\nIn fact, the App function itself is a component!One special prop to call out is children; unlike other props, children is defined as the contents of the tag (instead of as an attribute) and is always a ReactNode (an object that react knows how to render into HTML).\n// With this component definition\nfunction CustomTag(props) {\n  return <div>\n    Hello, {props.children}!\n  </div>;\n}\n// This: \n<CustomTag>\n  <span>world</span>\n</CustomTag>\n// Evaluates to this:\n<div>\n  Hello, <span>world</span>!\n</div>","fragments#Fragments":"Something that's not quite a component, but looks like one is a React Fragment: <Fragment> or <>.Fragments allow you to wrap multiple components as one, but don't render to any HTML themselves.\n// With this component definition\nfunction CustomTag(props) {\n  return <>\n    Hello, {props.children}!\n  </>;\n}\n// This: \n<p>\n  <CustomTag>\n    <span>world</span>\n  </CustomTag>\n</p>\n// Evaluates to this:\n<p>\n  Hello, <span>world</span>!\n</p>","reactivity#Reactivity":"Every app needs to do two things: (1) the initial render; (2) updating the UI in response to user interaction.Because React is a declarative framework, developers don't directly manipulate the DOM to update the UI; instead, developers describe the UI as a function of some data (called state), and update that state. When state is updated, React rerenders and computes any changes it needs to make to the DOM.","event-handlers#Event handlers":"Typically user interactions cause state to change. To listen to user interactions, event handlers can be passed like any other attribute to HTML primitives.","state#State":"State is created with useState(), which takes an initial value generator and returns a getter and setter tuple:\nconst [getter, setter] = useState(() => {\n  // ... does some expensive compute and returns initial state...\n  return 0;\n});\nState is updated by calling the setter with a function that takes in the old state and returns the new state.\n<div onClick={() => { setter((oldValue) => oldValue + 1) }} />\nOn click, the function passed to the setter is called, a new state is computed, and React triggers a rerender.\nTwo common shorthands for the above are:\nuseState(0) is equivalent to useState(() => 0): This is dangerous if the initial value is expensive to compute or shouldn't be recreated; for example, useState(new ComplexClass()) will create a new instance of ComplexClass every time the component rerenders.\nsetState(1) is equivalent to setState(() => 1): This is dangerous if the new value depends on the old value (setCount(count + 1)), as this code is evaluated at render time to setCount(2), and it will set the value to 2 regardless of how many times the user presses the button (until the frontend rerenders).\nBecause setState will trigger a rerender, you should avoid unconditionally calling setState during a render (as that will create an infinite render loop).","rerendering#Rerendering":"When state is updated in a component, React marks that component, and all of its descendent components, as \"dirty\"; whenever React has dirty nodes in its tree, it rerenders that subtree (React may rerender multiple subtrees simultaneously if they are all dirty and share no common ancestor that also needs rerendering).\nTo rerender a component, React:\nRenders: Calls the same function that initially rendered it\nReconciles: Compares its output against its previous output to create a list of changes\nCommits: Applies those changes to the DOM\nThe second step was the technical innovation behind React. Reading and writing to the DOM is expensive, but by keeping an in-memory representation of the DOM (a \"virtual DOM\"), developers only write one render function (as opposed to render and rerender) and React can quickly translate that into a list of updates.As React rerenders the tree, it needs to determine whether the node it's currently rendering is the same as a previous node it has rendered, so it can reuse the state. React determines this by looking at:\nIs the parent node the same (this algorithm is recursive)\nIs this component defined by the same function (\"same\" meaning pointer equality)\nIs the key the same (more on this later)\nThe second rule is why components should never be defined inside of another function. For example, the counter below will reset state on every render.\nfunction App() {\n  function Counter() {\n    const [count, setCount] = useState(() => 0);\n    return <div onClick={() => { setCount((oldCount) => oldCount + 1); }}>\n      Click me (current count: {count})\n    </div>;\n  }\n  return <Counter />;\n}","lists-and-keys#Lists and keys":"Reconciling state across elements of a list is tricky because every element has the same parent node and the same function. In the below exmaple, type something into one of the textboxes and click \"add item\".\nThe state will move components. This is because, by default, React will use the item's index to resolve any ambiguity in which child a state belongs to. You can override this by providing a key attribute, keys tell React how to match children elements across rerenders. This line would fix the example above.\n{items.map((item) => { \n  return <Item id={item} key={item} />; \n})}\nWhile primarily used for lists, keys are a general concept in react, and changing a key will reset the state.","example-inputs#Example: inputs":"One place where this all comes together beautifully is when dealing with input tags.\nIn a controlled input (where the value is defined in React),\nReact renders an input tag that says \"hello, w\"\nThe user types \"o\" into that input tag\nThe event handler triggers, and reads whats in the input (\"hello, wo\")\nReact updates the state to match that value\nReact rerenders (because state was updated)\nReact reconciles the differences to determine it should issue an update to the input from \"hello, w\" (what was in the virtual dom) to \"hello, wo\" (what was most recently rendered)\nThe DOM update no-ops (because \"hello, wo\" is already the value)","hooks#Hooks":"useState is actually one of many built-in React \"hooks\", or integration points with React. Hooks provide access to information stored across renders or hook into React's lifecycle.You may have wondered how useState worked across renders, React knows when a component is rendering, and tracks the order of hook calls. For example, when rerendering the below, React knows to return \"John\" for the first useState call and \"Doe\" for the second call:\nfunction SomeComponent() {\n  const [firstName, setFirstName] = useState(\"John\");\n  const [lastName, setLastName] = useState(\"Doe\");\n  // ...\n}\nHooks are always prefixed with use, and--because of their implementation--have two important rules:Rule 1: Even though components are JavaScript functions, don't call them directly (e.g. never call const element = SomeComponent()) because React does set-up before it renders components to enable hooks.Rule 2: Hooks must be called in the same exact order on every render. That means, hooks should not be called conditionally (in an if-statement) or a variable number of times (in a loop). For example, as far as React is concerned, the first name state and last name state are the same: the second call to useState.\nFor a full list of built-in hooks, see the documentation. In addition, you can define your own hooks, just be sure to prefix them with use.","lifecycle#Lifecycle":"While rendering and rerendering are intended to be implementation details of React, sometimes you need to take action throughout the component's lifecycle. useEffect is a hook that takes in a function to call whenever the component has been rendered; it returns a function to call either before the component is rendered again or before it is removed from the DOM.A common use-case for this is to synchronize the component with external sources of data. For example, here is a custom hook that stores the window size in state (so your component can react to it):\nconst useWindowSize = () => {\n  const [windowSize, setWindowSize] = useState({\n    height: window.innerHeight,\n    width: window.innerWidth,\n  });\n  useEffect(() => {\n    const windowSizeHandler = () => {\n      setWindowSize({\n        height: window.innerHeight,\n        width: window.innerWidth,\n      });\n    };\n    // Subscribe when component is created\n    window.addEventListener(\"resize\", windowSizeHandler);\n    return () => {\n      // Unsubscribe when component is removed\n      window.removeEventListener(\"resize\", windowSizeHandler);\n    };\n  }, []);\n  return windowSize;\n};\nBecause you may not want to run code on every render, useEffect takes in a second parameter, a list of values. If provided, useEffect will only rerun if one of those values changes. In our example, because we are passing an empty list, useEffect will only run when the component is first created.","refs#Refs":"In addition to wanting to run code on render, sometimes you need escape hatches from React's declarative nature and access the DOM elements that React creates. Refs are how you do that.In React, for historical reasons, ref refers to two related, but distinct, conceptsuseRef(...): is a hook that takes in an initial value and returns a JavaScript object of the form { current: INITIAL_VALUE }. This is useful because you can set the current property to anything as a way to persist that data across renders (however, unlike state, changing it won't trigger a rerender).\nconst useIsFirstRender = () => {\n  // We're using a ref instead of state, because we don't want checking \n  // whether we're on the first render to immediately trigger a rerender.\n  const firstRenderRef = useRef(true);\n  const isFirstRender = firstRenderRef.current;\n  firstRenderRef.current = false;\n  \n  return isFirstRender;\n};\nref={...}: is a property on every tag in React that takes in a ref object and provides an imperative handle to that DOM element. For example, the below creates a text element which auto-focuses when rendered:\nCustom components can also have refs, you can either forward the ref to one of the returned DOM nodes using forwardRef, or define a custom value to use as the value for the ref using useImperativeHandle.For more complicated use-cases, for example when you have a variable amount of elements you need refs to, you can instead pass a function to ref={...} that takes in the current DOM node.\nfunction CustomTag() {\n  // This will call focus on itself EVERY time it's rendered\n  // A more practical example would be to add the ref to an array\n  return <input type='text' ref={(element) => element.focus()} />;\n}","file-structure-locality#File structure (locality)":"Like functions do in normal JS, components create a natural place to introduce abstraction to your code:\nroot.render(\n  <App>\n    <Header />\n    <MainContents>\n      <Sidebar />\n      <SignUpPage />\n    </MainContents>\n  </App>\n);\nThis abstraction is typically reflected in the file structure:\nproject-root/\n  components/\n    Header/\n      Header.jsx \n    Sidebar/\n      Sidebar.jsx \n    MainContents/\n      MainContents.jsx \n  pages/\n    SignUpPage/\n      SignUpPage.jsx\nConventionally--and unlike other programming paradigms--in a component-based architecture, all parts of a component (code, style, tests) are co-located to optimize discoverability (a principle referred to as locality).\nproject-root/\n  components/\n    Header/\n      Header.jsx \n      Header.test.jsx\n      Header.css","styling#Styling":"Speaking of styling: in recent years, CSS has transformed in many of the same ways as JavaScript has:\nBetter syntax: LESS and SASS have emerged as alternative syntaxes to CSS.\nModularization: CSS modules help developers isolate code.\nBetter support for components: With CSS modules and a bundler (like webpack), I can now author a React component that imports a style and references any defined classnames like variables.\nimport s from \"./my-style-file.module.scss\";\nfunction SomeReactComponent() {\n  return <div className={s.someClassname}>Hello, world!</div>\n}\nThe above is my recommended way to write CSS; however, I'm keeping my eye on the efforts to colocate CSS definitions in JS (much like JSX moved HTML into JS files). Two examples are StyledComponents and StyleX. I believe this is the right long-term direction, but there are still unsolved challenges around:\nPsuedo-selectors (:hover)\nPsuedo-elements (::before)\nKeyframes (@keyframes)\nMedia queries (@media)\netc.\nIf you can't use CSS modules for whatever reason, BEM provides a structure to map your CSS to components."}},"/ui-patterns":{"title":"UI patterns: transcending style","data":{"":"As you start to look at more mocks through the lens of frontend development, you'll notice patterns and concepts that transcend the specific style. While different places call these elements different things, the goal of this chapter is to provide you with a vocabulary for some of the more common patterns.","layouts#Layouts":"Most web pages have some content at the top (called a header), some content in the middle, and some content at the bottom of the page (called a footer). If the header or footer follow you as you scroll, they are referred to as sticky (e.g. a sticky header).In addition, many sites have a column to the side of the content (typically used for navigation): a sidebar.","containers#Containers":"Beyond the overall layout of the page, there are various types of containers for other content.A section is probably the most generic term and refers to any part of the page. A panel is a section that is well defined (has a border or distinct background). A card is a panel that is stand-alone and typically appears elevated above the content. A drawer is a card or panel that the user can click on to expand, and an accordion is a stack of drawers.A banner spans the width of the page (or almost the width) and informs the user of something. A callout is the same, but not at the top of the page.","tabs#Tabs":"Sometimes you have many different pieces of content that need to fit in the same section:\nIf you can click on labels to see that different content, you have tabs\nIf the different content automatically cycles between itself, you have a carosel.","fullscreen-experiences#Fullscreen experiences":"If you display something above the content that disables interaction with things below it, it's called a modal.If the modal is attached to the side of the screen it's called a sidepanel.If it comes from the bottom of the screen (common on mobile), it's called a bottom sheet.","text-content#Text content":"Within text, there are many common elements, my recommendation is to look at a markdown cheatsheet for examples of:\nheadings\nparagraphs\nblock quotes\ntables\nlists\netc.","dynamic-data#Dynamic data":"When dealing with user-provided data, two common states developers need to handle with are:\nAn error state: when the data can not be fetched or rendered, and\nAn empty state: when there is no data; also called a null state","loaders#Loaders":"While data is being fetched, the user needs to know that data is being fetched and that the application hasn't frozen on them. A few strategies to do that are:\nSpinners: useful when it's not known how long data will take to fetch.\nShimmers: serves the same purpose as a spinner, but minimizes layout shift by taking the rough shape of the final content.\nProgress bar: shows how much progress has been made. When fetching data for a page, it's becoming increasingly common to show at the border of the page or element.","inputs#Inputs":"Form elements are any elements that allow the user to provide input. Some examples are:","buttons#Buttons":"A button is probably the most straightforward element. You click it, and something happens.Optionally, a button will have a chevron next to it allowing you to pick other actions.Like all form elements, buttons can be disabled (this means they show up as non-interactive).","toggles#Toggles":"Toggles let the user pick between some predefined states.\nCheckbox: A box that the user can check or not.\nRadio button: A group of checkboxes where only one is selectable.\nToggle: Functionally the same as a checkbox, but communicates you're turning something","dropdowns#Dropdowns":"Another way to let users pick between options is a dropdown. The user clicks on a button and opens up a menu where they can select one (or more) options.If this menu has a search box, it's called a combobox.","textboxes#Textboxes":"Lastly, sometimes users need a place to input text. This is a textbox. A textbox can have somet type of validation, for example, calendar, phone, or number validation (which optionally pop up additional UI).A textbox can autocomplete. If a textbox can autocomplete and select multiple options, it's called a pill selector: as the options are usually shown as \"pills\" in the textbox.If the textbox is many lines, it is called a textarea.","menus#Menus":"While not technically a form element, menus add additional functionality without cluttering the UI.If a button opens an additional piece of UI (that floats above the rest of the content), this is generally called a popover. Popovers are frequently used to implement menus. (If, instead, the user hovers to bring up a popover, this is called a tooltip or hovercard. These are usually informationally.)The most common type of menu you'll see in designs is a kebab or hamburger menu (named after the icon). Typically hidden in the top right of content. Clicking this menu opens a popover.A menu opened on right click is called a context menu.One specific element which is increasingly common is a command bar, it is usually summoned with \"command k\" and allows the user to pick among options (both global, and related to the currently selected element).","applications#Applications":"As your application becomes more complex, you'll need to communicate state to the user.Hints that help new users onboard are called NUXs (new user experiences); while there is no specific design, a few common options are to float them in the bottom left or above the relevant UI element.A toast is a container that pops up (hence the name; usually somewhere along the bottom of the screen), and alerts the user of something related to an action they just took.Lastly, breadcrumbs help the user navigate where they are (if you think of the website like a folder structure)."}}}