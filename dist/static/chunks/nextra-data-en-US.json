{"/graphics":{"title":"Graphics: adding wow","data":{"":"Gifs, videos, CSS animations.Vector vs Raster","svgs-declarative-graphics#SVGs: declarative graphics":"A view box","embedding-html#Embedding HTML":"Putting HTML in it with whatever","css-interop#CSS interop":"","svg-animation#SVG animation":"","lottie#Lottie":"","graphing-libraries#Graphing libraries":"","canvas-pixel-perfect-control#Canvas: pixel perfect control":"","libraries#Libraries":"","webgl-gpu-performance#WebGL: GPU performance":"","threejs#ThreeJS":"Other 2D libraries (such as Pixi)","react-three-fiber#React three fiber":""}},"/client-compute":{"title":"Compute: the universal virtual machine","data":{"thick-vs-thin-clients#Thick vs Thin clients":"Maybe add something about https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_shadow_DOM to the design systems library","threads#Threads":"","arraybuffers#Arraybuffers":"https://whatpwacando.today/","wasm#WASM":"","the-universal-virtual-machine#The universal virtual machine":"Speaking of evolution, people who really believe in the web platform will tell you it’s a full fledged virtual machine: a sandboxed render engine and scripting environment that runs on virtually every device.One technological arc to highlight is the compilation of traditionally native languages into JavaScript.It started with ASM.js and Emscripten: ASM.js was a subset of JavaScript intended as a compile target, and Emscripten was a backend for LLVM (a very common compiler with support for C, C++, ObjC, etc.). Emscripten could compile native code into ASM.js and even render graphics APIs directly to the screen via Canvas (JavaScript’s realtime drawing APIs).This made for interesting technical demos, but became very real with WASM (or WebAssembly), a browser-supported compile target for the web that was (1) safe, and (2) directly transformable into native bytecode. This made it much faster than anything interpretted; some of the early benchmarks of WASM showed that it was only 2x slower than native! While the might seem like a high number, imagine being able to run PhotoShop in your browser with only 2x overhead compared running native... that’s really fast.While WASM is not yet widely used in production (some notable exceptions being Figma, which uses it to power their editor, and Google Sheets, which uses it to power their formulas), there are very cool demos:\nDOOM 3\nGoogle Earth\nWindows 95\nFor something between satire and reality, The Birth and Death of JavaScript is a funny talk that becomes more real every day."}},"/state":{"title":"State: what drives your application","data":{"":"As you scale your application, you will inevitably need two parts of your app, which are not near each other visually or in the DOM, need to access the same data; for example, consider a code editor with a file tree on the left. Opening a file needs to update the main window and also the file tree (to highlight the file).The common response to this is to \"elevate\" the state to the nearest shared ancestor, and thread the state, and its setter, down to both components via props.","the-default-prop-drilling#The default: prop drilling":"Do this enough, and you'll find your codebase looking like this:\n<MyComponent\n  currentlyOpenFile={...}\n  setCurrentlyOpenFile={...}\n  currentWorkingDirectory={...}\n  setCurrentWorkingDirectory={...}\n  tabsOrSpaces={...}\n  setTabsOrSpaces={...}\n  zoomLevel={...}\n  setZoomLevel={...}\n  {...evenMoreProps}\n/>\nThis quickly becomes hard to manage, and slows down development of your application. Every piece of application-level state now needs to be created at the top and threaded through N-many levels of your tree.This is called prop drilling, and is the sign that your application has out-grown basic state management.","architecture#Architecture":"One way to reduce prop drilling is to rearchitect your application to construct the components that need state closer in the tree to where that state is defined.","composition#Composition":"Imagine we're building an app, and in the top right there is a dropdown that lets the user:\nSwitch accounts\nGo to the settings page\nSign out\nThe state of which accounts the user can switch to, the current page, and sign in status are all stored at the root. One way, and probably the default way, to build this is to drill all of the props:\nfunction App() {\n  return <>\n    <Header\n      allAccounts={[...]}\n      switchAccounts={(newAccount) => { ... }}\n      switchPages={(newPage) => { ... }}\n      signOut={() => { ... }}\n    />\n    {...}\n  </>\n}\nfunction Header(props) {\n  return <>\n    <Dropdown\n      allAccounts={props.allAccounts}\n      switchAccounts={props.switchAccounts}\n      switchPages={props.switchPages}\n      signOut={props.signOut}\n    />\n    {...}\n  </>\n}\nfunction Dropdown(props) {\n  return <>\n    <SwitchAccountsItem\n      allAccounts={props.allAccounts}\n      switchAccounts={props.switchAccounts}\n    />\n    <GoToSettingsItem switchPages={props.switchPages} />\n    <SignOutItem signOut={props.signOut} />\n  </>\n}\nHowever, this makes the code brittle to changes, as any new prop will now need to be added to multiple layers of components; another option is to pass the children elements into the Dropdown:\nfunction Header(props) {\n  return <>\n    <Dropdown>\n      <SwitchAccountsItem\n        allAccounts={props.allAccounts}\n        switchAccounts={props.switchAccounts}\n      />\n      <GoToSettingsItem switchPages={props.switchPages} />\n      <SignOutItem signOut={props.signOut} />\n    </Dropdown>\n    {...}\n  </>\n}\nfunction Dropdown(props) {\n  return <>\n    {props.children}\n  </>\n}\nAnd this pattern can extend to the header:\nfunction App(props) {\n  return <>\n    <Header dropdown={\n      <Dropdown>\n        <SwitchAccountsItem\n          allAccounts={[...]}\n          switchAccounts={(newAccount) => { ... }}\n        />\n        <GoToSettingsItem switchPages={(newPage) => { ... }} />\n        <SignOutItem signOut={() => { ... }} />\n      </Dropdown>\n    } />\n  </>\n}\nfunction Header(props) {\n  return <>\n    {props.dropdown}\n  </>\n}\nfunction Dropdown(props) {\n  return <>\n    {props.children}\n  </>\n}\nThe advantage of this is that if the account switcher needs new props, or you want to add another item to the dropdown, there is no need to drill props. This pattern is called composition over inheritance, and is recommended by the React docs themselves.","render-props#Render props":"Composition works great, but it breaks down when you have a component that needs props from multiple layers in the component tree. For example, consider the same dropdown case, but you want to close the dropdown menu if the user changes accounts--well now we have a problem: the state of whether the dropdown is opened is handled within the <Dropdown> component, but all the other state is at the root.We can solve this with a render prop: rather than passing children, pass a function that returns children:\nfunction App(props) {\n  return <>\n    <Header dropdown={\n      <Dropdown items={(closeDropdown) => {\n        return <>\n          <SwitchAccountsItem\n            allAccounts={[...]}\n            switchAccounts={(newAccount) => { ... }}\n            closeDropdown={closeDropdown}\n          />\n          <GoToSettingsItem switchPages={(newPage) => { ... }} />\n          <SignOutItem signOut={() => { ... }} />\n        </>;\n      }} />\n    } />\n  </>\n}\nfunction Dropdown(props) {\n  return <>\n    {props.dropdownItems(() => { ... })}\n  </>\n}","context#Context":"If neither of those are possible, React does have a way to pass data to arbitrarily deep descendents: context.Context is defined globally (with a default):\nimport { createContext } from 'react';\nexport const TotalTodosContext = createContext(0);\nSet somewhere in the tree:\nfunction App() {\n  const [todos, setTodos] = useState([]);\n  return <TotalTodosContext.Provider value={todos.length}>\n    {...}\n  </TotalTodosContext>;\n}\nAnd can be read in any descendent:\nfunction DeleteAllTodosButton() {\n  const totalTodos = useContext(TotalTodosContext);\n  return <button>\n    Delete {totalTodos} todos\n  </button>;\n}\nIf a component tries to read context, and no ancestor set it, the context call will get back the default.","an-implicit-dependency#An implicit dependency":"While context seems magical, I would strongly caution against using it for any value that's not truly global in your app. The reason is that it's an implicit, and unmarked, dependency: imagine a function that before you call it you had to set a specific global variable... if that's not somehow marked on the function, it's likely to be forgotten as that code is refactored or reused. The same is true of context.Imagine you're developing an online shopping website:\nYou've written the shopping cart component that has an item component that takes in a product name, quantity, and price and displays it to the user.\nLater on, someone decides that each row in the shopping cart should allow users to right click to remove the item from the shopping cart. Not wanting to drill another method, you decide that each item should reach into a shopping cart context to remove itself from the cart.\nSometime later, a different developer is working on the past orders page, likes the display of the \"list of items\" component from the shopping cart, and reuses it (unaware of the remove from cart behavior).\nUnfortunately, because neither the ShoppingCartListOfItems component or the ShoppingCartItem component obviously depended on the shopping cart context, when a user right clicks to remove an item not in the shopping cart, at best it will do nothing and at worst it will crash. Had those components declared their dependencies, this wouldn't have happened.Now one could argue that the developer should have fully audited the component before they chose to reuse it, but that becomes prohibitively expensive as the app scales. Imagine you're making a food ordering app, and there is a map view to see restaurants, and when you click on a restaurant a carosel of pictures pops up, and if you click a picture it adds it to the current order.Now someone decides to reuse that map to show previous pickup orders, unaware that if the user were to click on a different restaurant, and then click on an image in the popped up carosel it would crash the app because there is no \"current order\" context.","extracting-state#Extracting state":"With all this complexity, you might be wondering: \"well, why store my state in React at all?\"The short version is because React needs to know when state changes so it can rerender. If you were to store all of your state in a global variable and just tell the root-most React element to rerender, React would have no idea which child, or memoized, components to rerender.If you were particularly ambitious you might ask, \"well, can I keep track of which components need to be rerendered and then tell that to React\", and the answer is yes and there are libraries that will do that for you.","external-state-stores#External state stores":"These libraries are called external state stores, and were created in response to the issue of having complex application state used at many levels in the application's component tree.The most popular libraries here are:\nRedux: Probably the most popular state manager (and one of the first); it was intended as a general purpose library (and can be used without) React, but has solid support with custom React hooks.\nRecoil: Second to Redux, this is a state manager focused solely on React.\nZustand: The lightest-weight option, makes it very easy to define small state stores.\nMobX: Ultra-focused on performance, but somewhat of a boilerplate-heavy syntax; it was introduced to me as the \"enterprise option\", and in many ways I agree with that analysis.\nUnlike other technologies in the React ecosystem, I don't think there is a clear winner here.All of these libraries have:\nsome way to define state\nsome way to read state\nsome way to set state\nHere is an example of what working with one of these libraries, in this case MobX, is like:\n// State is defined as a class with both getters and settings\nclass TodoState {\n  // state is defined as properties\n  public todos = []\n  constructor() {\n    makeAutoObservable(this);\n  }\n  // setters are defined as actions\n  addTodo(todo) {\n    this.todos.push(todos)\n  }\n}\nconst GLOBAL_TODO_STATE = new TodoState();\n// All components that might read state must be wrapped in the `observer` higher order component\n// MobX will automatically rerender this if any state that it read during its last render changes\nconst TodoList = observer(() => {\n  return <div>\n    {GLOBAL_TODO_STATE.todos.map((todo) => {\n      // ...\n    })}\n  </div>;\n})\nThat said, you don't only have to store MobX globally, you can also store it locally:\nfunction App() {\n  const state = useState(() => new TodoState());\n  return <Children state={state} />\n}\nThis is better than prop drilling because you can wrap all of your states in one object; in many ways, this is a type-safe context, as you can explicitly declare your components dependencies and the component only rerenders if the specific properties of the state that it read change.","prefer-local-state#Prefer local state":"I'll caution against is that as you have a solution for a global state store, you might be tempted to put ALL of your state in there. Before you clutter your state store, two quesitons to ask are:\nDoes this state really need to be read from two different places in the tree (if you can, keep it local)?\nIs there another way to refactor this to avoid global state (composition, render props)?\nOne thing I would caution you against is reading text input values directly from a global state store:\n// DO NOT DO THIS\n<input type='text' value={GLOBAL_STATE_STORE.value.get()} onChange={GLOBAL_STATE_STORE.value.set} />\nSetting values in all of the external state managers may not be instant (they all have some overhead), and if React rerenders before it's been state the user may experience jumps or flickers while typing.","react-is-not-mvc#React is not MVC":"One thing I'll say is that as people start to run into issues of state management and prop drilling, I've seen developers turn to other, older patterns such as MVC or MVVM. React is not cleanly MVC or MVVM, and--in my experience--forcing your code to conform to either of those patterns is going to result in less-React-y code with heavy boilerplate and frustrating self-imposed restrictions."}}}