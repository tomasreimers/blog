{"/applications":{"title":"Applications: Composing components","data":{"":"Once you've started to write large parts of your website with React, the natural extension becomes why not write the whole website in React?","single-page-apps-spas#Single-page apps (SPAs)":"One of the most common ways to write React apps are \"single-page applications\" (abbreviated SPAs, and pronounced S.P.A.s). In a SPA, the entire application is bundled into a single web-page.","history-create-react-app#History: Create React App":"Although no longer officially supported by the React documentation, the defacto way to create an SPA was Create React App (abbreviated CRA, pronounced C.R.A): a scaffolder that sets up all the necessary build tooling for you (more on that in the next chapter), generates empty JS and CSS files for you to populate, and creates a single HTML file that looks something like this:\nThe boilerplate JS finds #root and mounts your React into it, so all you have to do is write React. In addition, CRA installs a package react-scripts that had scripts to develop, build, and test CRA projects.Like other scaffolders, that can be invoked directly from the command line without downloading anything:","vite#Vite":"Unfortunately, CRA is deprecated; however, Vite provides much of the same functionality:","react-router#React router":"While CRA only emits one HTML page, there are ways to make it seem as if your SPA has multiple pages.The simplest solution is what's called \"hash routing\", where your application has many \"pages\" and the URL encodes them after the \"hash\". Hashes in URLs are intended to link across different sections on the same page, because of that browsers don't send them up to the server and they don't trigger reloads:\nLinks (<a>) change the hash, and a framework can detect that and respond accordingly. One such framework is React Router, which acts as a switch statement mapping URLs to React components:\nBeyond hash routing, your SPA can also have \"real\" (path-based) URLs:\nThis is made possible by the history APIs that allows you to change the URL without reloading the page. Links are replaced with custom <Link> elements that take the same props as <a> tags, but instead of actually causing the browser to navigate, they change the URL and update internal state of what page to show.","deploying#Deploying":"Page-routing needs support from the server to work. For example, imagine I've navigated to \"your-single-page-app.com/sign-in\" and click refresh, the server returns a 404.SPAs are typically deployed in an environment where you tell the server to route all-non-existing routes to \"index.html\", which, on load, reads the URL and shows the correct component.A word of caution, an easy way to \"hack\" this behavior setting index.html to be a custom 404 page (a common configuration of what page to return when querying for paths that don't exist); however, this can harm your search engine ranking (frequently referred to as \"search engine optimization\", or SEO).","server-side-rendering-ssr#Server-side rendering (SSR)":"While SPAs are easy, they have a handful of problems:\nBecause the initial load has nothing, your first render for a user will be slow (as the browser needs to download all the JavaScript, parse it all, and execute it all before anything shows up)\nBecause the initial load has nothing, many search engines won't index the contents of your page (Google has updated its crawler to run JavaScript and wait for the page to resolve, but not all of them have)\nBecause the initial load has nothing, metadata tags (including what image to show when your link is shared on social media) won't be parsed by third-party services\nA simple solution here was to begin server-side rendering webpages: rather than serving the empty HTML file, use a Nodejs server to do the initial render, and prepopulate the HTML. React then does its initial render on the client, reconciling against the HTML that already exists (a process called hydration).","static-site-generation-ssg#Static-site generation (SSG)":"An alternative to SSR is to pre-render all of the pages at build time. While this doesn't work for pages that have user generated content or depend on the logged in user, it works great for blogs and documentation which know all of their content at build time.","nextjs#Next.js":"Setting up SSR or SSG can be tricky, and these days the React docs recommend using a framework to do that for you. Next.js is a framework built by much of the original React team that optimizes not only site generation, but a whole lot of other things.Much like Create React App, there is a Create Next App:","navigation#Navigation":"Out of the box, Next supports navigation. In Next there are two ways to define pages, the (now deprecated) pages router and the newer app router. An example project might look like:\nEach route is defined as folder paths within app/ and must terminate with a page.js. For example, this application would support the following URLs:\nAnd, in turn, each page.js must export a React component that represents the page.Much like React Router, Next provides a custom link that, on click, downloads the page and dynamically updates the DOM without triggering a browser refresh. (Something they confusingly name \"client-side navigation\", not to be confused with \"client-side routing\", what React Router does.)","server-components--actions#Server components / actions":"Because every page is rendered on the server, Next introduces the concept of server components and server actions that allow you to fetch data on the server or talk directly to your database.While it's possible to connect Next to your DB, many people choose not to use Next this way, and instead separate their API server from their Next server.","bundle-splitting#Bundle splitting":"Next.js automatically optimizes your JavaScript through bundle splitting. Instead of loading all JavaScript at once, Next.js breaks your code into smaller chunks. When a user visits a page, they only download the JavaScript necessary for that specific page, significantly reducing initial load times. As users navigate to different pages, Next.js loads additional JavaScript chunks as needed.","everything-else#Everything else":"Next does a ton of other things for you: it optimizes images, preloads links, and supports SSR, SSG, and ISR (a hybrid approach) out of the box (along with so many other features and optimizations).Next is configured through the next.config.js file (included at the root of your repo).","alternative-frameworks#Alternative frameworks":"There are other ways to set up server-side- and statically- rendered projects, including Gatsby, Remix, and Astro (Vite even has support for generating a server).Personally, I'm skeptical. For better, or for worse, Next.js now has a lot of the core React team working on it and is backed by a real company (Vercel), which leads me to believe it will both shape the direction of React and outlive the alternatives. That said, who knows, it may not be winner take all."}},"/components":{"title":"Components: The building blocks of UI","data":{"":"As JavaScript became more powerful, the browser transformed from a rendering engine into a sandbox. User expectations kept up and users demanded more: suddenly, it wasn't an acceptable user experience to refresh the page when a user added something to their shopping cart, or their password and confirm password fields didn't match, web apps were expected to compute and rerender those details client-side.The natural result was increasingly large parts of web pages had to be rendered on the client; however, there was no canonical way to do this. On the server, data was fetched in response to user requests and piped into templates, but the client lived in this awkward in-between where the initial render came from the server, but then subsequent renders and updates had to be constructed on the client.The split source-of-truth between initial render and updates led to predictable problems: HTML fell out-of-sync with data in JavaScript, and rerenders could change the UI in unexpected, and often unintentional, ways.","jsx-html-in-js#JSX: HTML in JS":"It is in this context that JSX was born. Technologically, JSX wasn't that interesting, but as a developer experience improvement, it was genius. JSX flipped the paradigm on its head: JavaScript, not HTML, became the source of truth for all renders (including the initial render). Because that required more HTML to be written in JavaScript than before, JSX introduced a first-class HTML-like syntax embedded within JavaScript: JSX.JSX takes in a DOM element, and mounts a React tree into it using the .render() method. If you're using a higher-level framework (such as Next.js), this is typically handled for you.\nJSX enabled this syntax by adding a build step to transpile the HTML-like syntax into JavaScript functions.Not only could you render HTML inside of JavaScript, but you could also interpolate JavaScript back into HTML using curly braces.","components#Components":"Beyond letting developers write the standard HTML tags, JSX allowed developers to define their own tags, called components, using JavaScript functions (tags native to HTML are called \"primitives\").Like normal functions, these tags evaluate to their return value and take in arguments (called props and passed as attributes to the tag).\nIn fact, the App function itself is a component!One special prop to call out is children; unlike other props, children is defined as the contents of the tag (instead of as an attribute) and is always a ReactNode (an object that react knows how to render into HTML).","fragments#Fragments":"Something that's not quite a component, but looks like one is a React Fragment: <Fragment> or <>.Fragments allow you to wrap multiple components as one, but don't render to any HTML themselves.","reactivity#Reactivity":"Every app needs to do two things: (1) the initial render; (2) updating the UI in response to user interaction.Because React is a declarative framework, developers don't directly manipulate the DOM to update the UI; instead, developers describe the UI as a function of some data (called state), and update that state. When state is updated, React rerenders and computes any changes it needs to make to the DOM.","event-handlers#Event handlers":"Typically user interactions cause state to change. To listen to user interactions, event handlers can be passed like any other attribute to HTML primitives.","state#State":"State is created with useState(), which takes an initial value generator and returns a getter and setter tuple:\nState is updated by calling the setter with a function that takes in the old state and returns the new state.\nOn click, the function passed to the setter is called, a new state is computed, and React triggers a rerender.\nTwo common shorthands for the above are:\nuseState(0) is equivalent to useState(() => 0): This is dangerous if the initial value is expensive to compute or shouldn't be recreated; for example, useState(new ComplexClass()) will create a new instance of ComplexClass every time the component rerenders.\nsetState(1) is equivalent to setState(() => 1): This is dangerous if the new value depends on the old value (setCount(count + 1)), as this code is evaluated at render time to setCount(2), and it will set the value to 2 regardless of how many times the user presses the button (until the frontend rerenders).\nBecause setState will trigger a rerender, you should avoid unconditionally calling setState during a render (as that will create an infinite render loop).","rerendering#Rerendering":"When state is updated in a component, React marks that component, and all of its descendent components, as \"dirty\"; whenever React has dirty nodes in its tree, it rerenders that subtree (React may rerender multiple subtrees simultaneously if they are all dirty and share no common ancestor that also needs rerendering).\nTo rerender a component, React:\nRenders: Calls the same function that initially rendered it\nReconciles: Compares its output against its previous output to create a list of changes\nCommits: Applies those changes to the DOM\nThe second step was the technical innovation behind React. Reading and writing to the DOM is expensive, but by keeping an in-memory representation of the DOM (a \"virtual DOM\"), developers only write one render function (as opposed to render and rerender) and React can quickly translate that into a list of updates.As React rerenders the tree, it needs to determine whether the node it's currently rendering is the same as a previous node it has rendered, so it can reuse the state. React determines this by looking at:\nIs the parent node the same (this algorithm is recursive)\nIs this component defined by the same function (\"same\" meaning pointer equality)\nIs the key the same (more on this later)\nThe second rule is why components should never be defined inside of another function. For example, the counter below will reset state on every render.","lists-and-keys#Lists and keys":"Reconciling state across elements of a list is tricky because every element has the same parent node and the same function. In the example below, type something into one of the textboxes and click \"add item\".\nThe state will move components. This is because, by default, React will use the item's index to resolve any ambiguity in which child a state belongs to. You can override this by providing a key attribute, keys tell React how to match children elements across rerenders. This line would fix the example above.\nWhile primarily used for lists, keys are a general concept in react, and changing a key will reset the state.","example-inputs#Example: inputs":"One place where this all comes together beautifully is when dealing with input tags.\nIn a controlled input (where the value is defined in React),\nReact renders an input tag that says \"hello, w\"\nThe user types \"o\" into that input tag\nThe event handler triggers, and reads whats in the input (\"hello, wo\")\nReact updates the state to match that value\nReact rerenders (because state was updated)\nReact reconciles the differences to determine it should issue an update to the input from \"hello, w\" (what was in the virtual dom) to \"hello, wo\" (what was most recently rendered)\nThe DOM update no-ops (because \"hello, wo\" is already the value)","hooks#Hooks":"useState is actually one of many built-in React \"hooks\", or integration points with React. Hooks provide access to information stored across renders or hook into React's lifecycle.You may have wondered how useState worked across renders, React knows when a component is rendering, and tracks the order of hook calls. For example, when rerendering the below, React knows to return \"John\" for the first useState call and \"Doe\" for the second call:\nHooks are always prefixed with use, and--because of their implementation--have two important rules:Rule 1: Even though components are JavaScript functions, don't call them directly (e.g. never call const element = SomeComponent()) because React does set-up before it renders components to enable hooks.Rule 2: Hooks must be called in the same exact order on every render. That means, hooks should not be called conditionally (in an if-statement) or a variable number of times (in a loop). For example, as far as React is concerned, the first name state and last name state are the same: the second call to useState.\nFor a full list of built-in hooks, see the documentation. In addition, you can define your own hooks, just be sure to prefix them with use.","lifecycle#Lifecycle":"While rendering and rerendering are intended to be implementation details of React, sometimes you need to take action throughout the component's lifecycle. useEffect is a hook that takes in a function to call whenever the component has been rendered; it returns a function to call either before the component is rendered again or before it is removed from the DOM.A common use-case for this is to synchronize the component with external sources of data. For example, here is a custom hook that stores the window size in state (so your component can react to it):\nBecause you may not want to run code on every render, useEffect takes in a second parameter, a list of values. If provided, useEffect will only rerun if one of those values changes. In our example, because we are passing an empty list, useEffect will only run when the component is first created.","refs#Refs":"In addition to wanting to run code on render, sometimes you need escape hatches from React's declarative nature and access the DOM elements that React creates. Refs are how you do that.In React, for historical reasons, ref refers to two related, but distinct, conceptsuseRef(...): is a hook that takes in an initial value and returns a JavaScript object of the form { current: INITIAL_VALUE }. This is useful because you can set the current property to anything as a way to persist that data across renders (however, unlike state, changing it won't trigger a rerender).\nref={...}: is a property on every tag in React that takes in a ref object and provides an imperative handle to that DOM element. For example, the below creates a text element which auto-focuses when rendered:\nCustom components can also have refs, you can either forward the ref to one of the returned DOM nodes using forwardRef, or define a custom value to use as the value for the ref using useImperativeHandle.For more complicated use-cases, for example when you have a variable amount of elements you need refs to, you can instead pass a function to ref={...} that takes in the current DOM node.","higher-order-components#Higher order components":"In many ways, components are like functions, and like functions, you may find yourself writing the same logic over and over again as you write more of them. When working with functions, you can reduce this repetition with higher order functions, and the same concept exists with components: higher order components (HOCs).Higher order components are functions that return components. For example, imagine you wanted every page to log whenever it rendered. Because of that you found every page beginning with the same:\nInstead of copy and pasting that across components, you could create a higher order component:\nAnd then create your components like this:\nThat said, these days I don't see higher order components as much because hooks make a lot of that same logic reuse easier. For example, another way to implement the above is as a custom hook:\nIf you do find yourself creating HOCs, make sure to create them in the global scope of your application (and not during render), because React uses the function pointer to determine component equality, and if you create a new component function every render, React will never reconcile state across them.","file-structure-locality#File structure (locality)":"Like functions do in normal JS, components create a natural place to introduce abstraction to your code:\nThis abstraction is typically reflected in the file structure:\nConventionally--and unlike other programming paradigms--in a component-based architecture, all parts of a component (code, style, tests) are co-located to optimize discoverability (a principle referred to as locality).","styling#Styling":"Speaking of styling: in recent years, CSS has transformed in many of the same ways as JavaScript has:\nBetter syntax: LESS and SASS have emerged as alternative syntaxes to CSS.\nModularization: CSS modules help developers isolate code.\nBetter support for components: With CSS modules and a bundler (like webpack), I can now author a React component that imports a style and references any defined classnames like variables.\nThe above is my recommended way to write CSS; however, I'm keeping my eye on the efforts to colocate CSS definitions in JS (much like JSX moved HTML into JS files). Two examples are StyledComponents and StyleX. I believe this is the right long-term direction, but there are still unsolved challenges around:\nPseudo-selectors (:hover)\nPseudo-elements (::before)\nKeyframes (@keyframes)\nMedia queries (@media)\netc.\nPrior to CSS modules, BEM provided a structure to map your CSS to components."}},"/design-systems":{"title":"Design systems: Scaling style","data":{"":"For many developers, frontend development is the first time they have to work with a designer.There are many types of designers, and you are probably working with a product designer (as opposed to a visual designer). Simply put, the job of a product designer is to understand the user problem and create a product that solves it, using principles of design thinking. It is your job to build that product.Designers output \"mocks\" or still images of what the product should look like, along with documentation of any edge cases to be mindful of or transitions that aren't immediately obvious.There are many ways designers hand off mocks, but these days, the most common is Figma:\nImplementing mocks to be pixel perfect seems like a lot, but--in the same way there are with codebases--there are patterns and concepts that transcend the design and make it easier to understand.","layout-and-the-grid#Layout and the grid":"One of the first things to note when looking at designs is how is it all laid out. In general, there are two approaches to laying out web pages:\nFixed: The main content of the website has a maximum width it will grow to.\nFluid: The main content of the webpage will expand to fill the screen.\nFor fixed layouts (and sometimes fluid ones as well, although less commonly), typically designs are made on a 8 or 12 column grid. This helps ensure items are visually aligned.","spacing#Spacing":"Extending the idea of the grid, designers usually work with a common multiple for all paddings and widths. For example, by keeping all dimensions a multiple of 8px, it's much easier to make sure that all elements on your site are aligned and for developers to identify whether the space between elements is meant to be 8px or 16px (something that's easier to eye-ball than 8px or 7px).","responsive-design#Responsive design":"Responsive design refers to a set of practices to make your webpage look good at various screen sizes. Progressive enhancement takes this a step further and designs for the most limited browser (typically mobile), adding in features as the browser or screensize can support them. A common analogy in the space is an escalator works as a stair, and if it has power it enhances to something more powerful.","defensive-css#Defensive CSS":"In general, but especially if you're app contains user generated content, it's important to design for a wide variety of content (including extra-long content, foreign characters in usernames, and odd screen sizes) to make sure it does not mess up your layout.A wonderful catalog of common techniques is defensive css.","typography#Typography":"Typography refers to the text and font-styles in an app. There are typically only a few of them (for example: heading, large heading, subtitle, body text), and each style defines a subset of:\nFont (Google fonts has many fonts for you to use)\nFont size\nFont weight (how bold the text is; a multiple of 100 between 100 and 900; default is 400, bold is 700)\nColor\nLine height (space between lines)\nLetter spacing (space between letters)\nFont style (e.g. italics) and decorations (e.g. underlined)\nCasing (e.g. all uppercase, sentence case, title case.)","colors#Colors":"There are usually only a few colors used within an app (the collection of which is called a palette). There are many ways to generate a palette, but they typically involve picking a primary color and some supporting secondary colors. To play around and learn more about what makes different colors look good together, there are plenty of tools to help you play with color harmony: Adobe, Coolors, and Paletton.Once you've selected your colors, you need to pick the shades that will be used within your app. Increasingly commonly, developers will name their shades like font-weights (in increments of 100, with 100 being the lightest and 900 being the darkest). For example, here is Tailwind's default palette (more on Tailwind later):","themes#Themes":"Increasingly, apps in general, including web apps, are expected to support multiple themes (or sets of colors). At a minimum, users expect a light (a set of colors that have a light background) and a dark mode (a set of colors with a dark background).\nIn CSS, themes are typically implemented with CSS variables (having variables for background or text colors).","accessibility#Accessibility":"An important, and often overlooked / under-invested-in, job of a frontend developer is to make sure everyone can use the web app; by everyone I mean everyone, including people who are colorblind, who are visually impaired, and who have trouble using a mouse. This is called accessibility (or a11y for short).While there is a whole chapter, if not book, that could be written on accessibility, three things I'll call out are:\nEnsuring colors are visible, text has sufficient contrast with its background, and buttons are big enough for people who have trouble using a mouse--or are accessing the page on a mobile device--to tap. This kind of stuff is typically covered by human interface guidelines (for example, here's Apple's human interface guidelines) and handled by the designer.\nEnsuring your app is accessible to screen-readers (assistive technology that reads webpages to those who are visually impaired). The most basic thing you can do is ensure all images have an alt property; ultimately, you should ensure your components have the relevant ARIA properties and declare their role; for example, by annotating a dropdown menu, a screenreader can more easily navigate the content.\nEnsure your app is accessible via keyboard navigation. Frequently this involves setting the tabindex.","components#Components":"Even with the above patterns, all the above is a lot to think about for every part of every page. As a web app grows, designers abstract parts of the page into components: rather than needing to think about typography and colors and padding for every part of the site, designers can simply place a \"button\", and there is one canonical definition, complete with typography and colors and padding, for the button.Some common components include buttons, text inputs, headings, a sidebar, etc. We'll cover more components in the next section.","utility-classes#Utility classes":"In a perfect world, every possible semantic concept would have a component, and developers would not need to design anything outside of the design system. Unfortunately, we do not live in a perfect world and such a design system would be really extensive to make and maintain.A mid-way solution is to create css \"utility classes\" (or single purposes classes) that make it easier to create new components, so rather than having to create a new component or style for a page which needs to center its contents, I can instead write:","ui-patterns#UI patterns":"As you start to look at more mocks through the lens of frontend development, and build out your own components, you'll notice patterns and concepts that transcend the specific style. While different places call these elements different things, below are some of the common patterns you'll encounter.","containers-and-layout#Containers and layout":"Most web pages have some content at the top (called a header or navbar, as it's often used for navigation), some content in the middle, and some content at the bottom of the page (called a footer). If the header or footer follow you as you scroll, they are referred to as sticky (e.g. a sticky header).In addition, many sites have a column to the side of the content (typically used for navigation): a sidebar.Within the content of the page or in the sidebar:\nA section is probably the most generic term and refers to any part of the page.\nA panel is a section that is well defined (has a border or distinct background).\nA card is a panel that is stand-alone and typically appears elevated above the content.\nA drawer is a card or panel that the user can click on to expand.\nAn accordion is a stack of drawers.\nA banner is a panel at the top of the content (or above the navbar) spanning the width of the page (or almost the width) and informing the user of something, and\nA callout is a banner, that's not at the top of the page.\nSometimes you have many different pieces of content that need to fit in the same section:\nIf you can click on labels to see that different content, you have tabs\nIf the different content automatically cycles between itself, you have a carousel.","inputs#Inputs":"Within the content, you may have text, images, and inputs: elements that the user can use to enter data. For historical reasons, these elements are sometimes referred to as \"form elements\" (referencing a physical paper form that has checkboxes and space for written answers).Some common form elements are:\nButtons: A button is probably the most straightforward element. You click it, and something happens. Optionally, a button will have a chevron next to it allowing you to pick other actions. Like all form elements, buttons can be disabled (this means they show up as non-interactive).\nToggles: Toggles let the user pick between some predefined states.\nCheckbox: A box that the user can check or not.\nRadio button: A group of checkboxes where only one is selectable.\nToggle: Functionally the same as a checkbox, but communicates you're turning something on or off.\nDropdowns: Another way to let users pick between options is a dropdown. The user clicks on a button and opens up a menu where they can select one (or more) options.\nIf this menu has a search box, it's called a combobox.\nTextboxes: Lastly, sometimes users need a place to input text. This is a textbox. A textbox can have some type of validation, for example, calendar, phone, or number validation (which optionally pop up additional UI). A textbox can autocomplete. If a textbox can autocomplete and select multiple options, it's called a pill selector: as the options are usually shown as \"pills\" in the textbox. If the textbox is many lines, it is called a textarea.\nLastly, while not technically a form element, menus add additional functionality without cluttering the UI.If a button opens an additional piece of UI (that floats above the rest of the content), this is generally called a popover. Popovers are frequently used to implement menus. (If, instead, the user hovers to bring up a popover, this is called a tooltip or hovercard. These are usually informationally.)The most common type of menu you'll see in designs is a kebab or hamburger menu (named after the icon). Typically hidden in the top right of content. Clicking this menu opens a popover.A menu opened on right click is called a context menu.One specific element which is increasingly common is a command bar, it is usually summoned with \"command k\" and allows the user to pick among options.","stateful-ui#Stateful UI":"When building data rich applications, three common states developers need to handle are:\nAn error state: when the data can not be fetched or rendered,\nAn empty state: when there is no data; also called a null state, and\nThe loading state: when the data is still being loaded\nSome common loading states are:\nSpinners: useful when it's not known how long data will take to fetch.\nShimmers: similar to a spinner; minimizes layout shift by taking the rough shape of the final content.\nProgress bar: shows how much progress has been made. When fetching data for a page, it's becoming increasingly common to show at the border of the page or element.\nOn the flip side, a user may need to be guided through specific steps in a specific order.If you display something above the content that disables interaction with things below it, it's called a modal (sometimes called a dialog; however a common difference is a dialog doesn't prevent interaction with the other content below it). If the modal is attached to the side of the screen it's called a sidepanel. If it comes from the bottom of the screen (common on mobile), it's called a bottom sheet.","off-the-shelf-systems#Off-the-shelf systems":"Everything above comprises the design system. In an ideal world, new pages need minimal design intervention, because there is a self-evident way to build what needs to be built given the design system.Building a design system is a serious undertaking, and one that many developers chose to forego. There are many off-the-shelf systems that one can choose to use. Theo.gg has a good video describing the multiple types of design systems that exist.\nSome notable examples are:\nBootstrap: a full design system, includes colors, typography, fully-built components, etc.\nRadix: the functionality of a design system with none of the visual design. You still need to bring your own colors and typography, but it will implement the user experience: keyboard shortcuts, hover states, etc.\nTailwind: the opposite of Radix, design with little functionality. Provides default colors, typography, etc.\nShadUI: \"Not a design system\", provides copy-and-pastable components to use.\nAlso, many companies open source their design systems, for example: Google, Adobe, GitHub, and Vercel."}},"/graphics":{"title":"Graphics: Adding wow","data":{"":"Some graphics, visualizations, and other dynamic content cannot (easily) be expressed in HTML and CSS alone. For those, it might be worth switching to an alternative technology. As a general rule,\nStart with HTML and CSS\nIf you can't render the visualization in HTML, try SVG, which is a richer way to declaratively express graphics and illustrations (including first-class support for animations)\nIf SVGs are insufficient, because you need more interaction or graphical filters, canvas provides a full... well, canvas, that you can render on.","svgs-declarative-graphics#SVGs: declarative graphics":"While HTML and CSS are a wonderful declarative language to describe documents, they don't work so well for complex graphics. SVG is a declarative, XML format to describe graphics.Like HTML, SVG provides a handful of primitive tags; however, unlike HTML, those primitives are used for drawing (for example, line, rectangle, etc.)Because it's XML-based, SVGs can:\nBe embedded in HTML\nRendered with React\nAt their core, SVGs define shapes on an infinite canvas (somewhat like HTML), and then provide a \"viewbox\" or rectangle in that canvas that it should render (specified as two pairs of X/Y coordinates).\nSVGs can either be inlined (e.g. above), or they can be included as an img tag (by saving in a separate file and pointing the img tag's src attribute to that file).Unlike HTML, where the syntax is meant to be written by hand, the syntax for SVGs can get complicated quickly. For example, here is the syntax to define a polygon (the points are pairs of X/Y coordinates):\nFor that reason, many people use a library to generate SVGs (or just export them from an image editor).","css-interop#CSS interop":"Because SVG and HTML are so interoperable, CSS can actually effect both. For example,","embedding-html#Embedding HTML":"Not only can you embed SVGs in HTML, you can also embed HTML in SVGs using foreignObject:","svg-animation#SVG animation":"SVGs can be animated via the animate primitive (sometimes called SMIL).","lottie#Lottie":"Again, while animations can be written by hand, most designers prefer to iterate on them in a graphics editor and later export the animation. Lottie is a format developed by Airbnb to export SVG animations as JSON files.","canvas-pixel-perfect-control#Canvas: pixel perfect control":"While SVGs are powerful, sometimes you really want pixel-perfect control. For that, there is Canvas.Canvas allows developers to define an area that they can programmatically draw on.","libraries#Libraries":"Because the Canvas API is so low level, many people use a higher level library (e.g. Pixi and Fabric).","webgl-gpu-performance#WebGL: GPU performance":"If you start to use Canvas for realtime graphics (or games), you'll quickly run into a performance problem. This isn't specific to JavaScript, and why native apps leverage the graphics card for anything intense (a specialized piece of hardware that can quickly do mathematical operations involved in rendering 3D graphics).WebGL allows JavaScript to use the graphics card.","threejs#ThreeJS":"The APIs behind WebGL, especially for 3D, are really low level, and as a result, most people interact with it through a library, specifically Three.js. Three handles all of the internals of 3D rendering, and provides human-readable primitives for math, shapes, cameras, etc.","react-three-fiber#React three fiber":"Like many Graphics libraries, Three is imperative in nature; because it is not declarative, it can be awkward to use alongside React. React-three-fiber bridges that gap, by providing react primitives for Three concepts.\nIn addition, it will do all the necessary Three.js cleanup as elements are mounted and unmounted.","webgpu#WebGPU":"While WebGL is very powerful, it's also getting old. GPUs have really advanced in leaps and bounds over the past few years and the WebGPU spec is a successor to WebGL currently being implemented that provides access to new GPU features, and enables developers to leverage the GPU for general-purpose compute."}},"/html":{"title":"HTML: The structure of web pages","data":{"":"HTML started as a portable markup language to share academic papers with other people on the same network. Browsers were co-developed as a way to (1) fetch those files, and (2) display them.While the web has changed a lot since then, those core technologies haven't.","a-basic-page#A basic page":"The most basic HTML page you could write looks something like this:\nIn this example, we're creating a page that has a single paragraph, <p>, with the text \"Hello, world!\".HTML is a subset of XML, that is to say it encodes the document as a tree of tags; tags can be <opening>, </closing>, or <both />. Every opening tag must have a closing tag, and opening and self-closing tag (what we referred to as \"both\") can have attributes that change the behavior of the tag (for example, <img width=\"800\" /> is an image with a width of 800px). You can even define your own attributes if you prefix them with data- (this is used for scripting and is covered later).A tag nested within another tag is referred to as a child, and the outer tag is referred to as the parent:\nBuilding on that, the entire nomenclature for family trees applies (there are grandparents, siblings, descendants, etc...)HTML documents begin with a <!DOCTYPE html> declaration that tells the parser the document is HTML (much like a shebang in a scripting language), and consist of at most two children:\nhead: defining the metadata of the document (such as the tab's title)\nbody: defining the contents of the document (such as the paragraph with the text hello world to show)","tags-tags-tags#Tags, tags, tags":"If you were to only know 2 other tags beyond <html>, <title>, and <body> they would definitely be:\n<div>: an arbitrary block of content\n<span>: a way to select text within a block\nWe'll talk about both of these more in the CSS section.There are other common tags to add functionality to the page: <img> for images, <video> for videos, <textarea> for long-form text-input, but we don't need to understand those yet. There are also other tags that encode the purpose of the element: <main>, <article>, <header> (these act the same as a div, but allow bots and accessibility software to more easily read the webpage). My advice with these semantic elements is to use them where you can, but not to stress about them; there are still many, many websites that get along just fine with divs.","try-it-yourself#Try it yourself":"To play with this further, you can use a service like CodeSandbox, which allows you to define and render an HTML file (and allows you to define CSS and JS files, but more on that later).","the-browser-and-urls#The browser and URLs":"When you navigate to a URL like google.com/foo/bar.html, the browser requests the shared file foo/bar.html from the server at google.com; if you specify a folder path without a file, the browser will automatically request index.html on your behalf (specifically, the requests google.com/foo/ and google.com/foo/index.html are the same).URLs can also contain query parameters, which are used to pass information to the server. For example, google.com/search?q=hello will pass \"hello\" to Google as an argument as it generates the search page.While most of this is probably familiar to anyone who's worked with web services before, one part that's unique to the browser is the hashtag (#): an artifact of the browser's origins as a document viewer. If there is a hashtag, the browser will scroll to the corresponding a element with that ID; for example, navigating to #try-it-yourself will scroll to the element <a id=\"try-it-yourself\">.","embedding-media#Embedding media":"In addition to HTML, browsers can render and embed a variety of media files to make documents more rich. For example, they can handle a variety of images:\nJPEG: Lossy image files\nPNG: Lossless image files\nWEBP: Google-optimized image files\nSVG: Vector files, structured as XML\nThey can also natively embed audio and video through MP4s."}},"/":{"title":"👋 Hi! My name is Tomas.","data":{"":"I have been programming for the web for 15+ years, developed reactive frontend frameworks at Facebook, and absolutely love JavaScript.Over the past few years, I've found myself teaching frontend development to, primarily, backend developers. I was surprised I couldn't find a quick primer on the topic, so I made this ~20-page, front-to-back readable guide in the hope that it might help others.I hope you like it!"}},"/network":{"title":"Network: Old page, new data","data":{"":"Eventually, your application is going to want to talk to the server. Either to write new data (because the user updated something), or to read new data (because you believe it may be out of date).","transit-protocols#Transit protocols":"These days, there are two popular options when talking to the server:\nREST: The more traditional solution structured with verbs, URLs, and payloads.\nGraphQL: A newer alternative where the server defines what data the client can access through a shared schema, and the client defines what data (both objects and properties) it wants.\nGraphQL was developed at Facebook and has had a lot of development recently (after all, it is newer). Because of that, many startups choose GraphQL. Despite this, I would encourage you to think about do you really need GraphQL: it was developed by Facebook to solve a Facebook-sized problem: frontend developers can't write any backend code, and implementing it comes along with some pretty heavy restrictions (e.g. limiting how you can query for your data or how you have to structure your server).","rest-ish-patterns#REST-ish patterns":"For most developers and organizations, I believe REST (or something similar in spirit) to be the best answer.I say similar to REST, because I don't think you need to abide by the standard exactly (for example, REST would tell you never to query for data using a POST request, I don't know if that's true... many APIs implement query for data over POST because they want to send up a request body; more on this later).If you've worked with servers before, you've probably encountered REST, and so I'll try to keep this quick.REST is structured as many individual HTTP requests; each request has:\nA URL\nA \"verb\" (GET, POST, PUT, PATCH, DELETE)\nHeaders (fields separate from the body)\nA body (except for GET requests, GETs have no body)\nIn REST, each URL represents a unique object, and verbs dictate the intention of the request:\nGET: Read the object\nPOST: Create a new object\nPUT: Update the object by replacing it\nPATCH: Update the object by providing partial fields\nDELETE: Deletes the object\nFor example,\nGET /book/<id>: Get the book with the id <id>\nPOST /books: Create a new book\nPATCH /book/<id>: Update the book with the id <id>\nIn those requests, parameters can be encoded in:\nThe URL: for example, id above\nThe query parameters: anything following a question mark in the URL. In REST, the part of the URL before the question mark represents the object and after represents parameters.\nThe headers: additional request data encoded as a set of key-value pairs\nThe body: a freeform string sent as part of the request (GET requests don't have a body)\nThe browser will automatically add a lot of headers for you (including things like the user agent, describing your device). One header to call out are cookies: cookies are key value pairs that a server can send to the browser, and the browser will include in any subsequent requests (for example, for authentication).The server will receive the URL, verb, headers, and body and respond with:\nA document (probably XML or JSON encoded)\nA status code\nStatus codes are a coarse grain way to represent the kind of response to the client. For example, 200 means the request was handled as expected, 401 means the client needs to authenticate before making the request, 500 means the client made a well-formed request and the server ran into an issue processing it.In general,\n1xx status codes means the server is handling it\n2xx status codes means everything is alright\n3xx status codes means the server is directing you elsewhere\n4xx status codes means the client made a bad request\n5xx status codes means the server had an error\nIn Chrome's devtools, the network inspector can show you past requests and responses.","uploads#Uploads":"When working with JSON or XML APIs, one challenge is uploading files.Imagine creating an API for a social media site where users need to be able to upload an image and title.This is challenging because encoding the image is non-trivial. Four ways to do this are:\nHave a JSON API and send up the file contents as a base64 encoded string (the request body would be a dictionary containing the title string and the body)\nUse form multipart encoding instead of JSON (a legacy way to send files and data to the server; the request body would have title and image encoded as form multipart)\nEncode the title as a query parameter and have the body be the raw bits of the file (encoded as JPEG or PNG or whatever file format you choose); the downside here is that query parameters must be strings\nBreak it into two endpoints: one to create the post (takes in title and returns an upload URL), and one that just takes in the bits of the image (encoded as a JPEG or PNG)","pagination#Pagination":"Another challenge can be returning very long lists. By very long I mean that they couldn't fit in a single network response: for example, Google search results.For this, you need to paginate or turn the single list into many \"pages\" of results.Pagination all takes the same form: the client requests a page of results from the server, passing a \"cursor\" as a parameter. The server responds with a page of results and a new cursor for the next page.The simplest cursor is a page number, but that can be fragile (for example, what if the list reorders? Will the pages still be continuous?) For this reason, cursors typically encode some way to regenerate that initial list. For example, if writing a cursor for a chronological newsfeed, I might say page 2, only looking at posts from before a certain date. That would guarantee a stable ordering.","networking-in-react#Networking in React":"To actually make a network call from the client, you use the fetch function.\nFetch returns a promise containing the response.Tying this back to React, writing is straight-forward: you do it in response to user actions.\nReading is a little more complicated. In its simplest form, it looks something like this:\nHowever, this doesn't handle things like retries, failed requests, race conditions, or if the component is unmounted before the request returns. You probably don't want to implement data fetch yourself, and there are many good libraries that will handle this for you (such as React Query and SWR).Lastly, in the same vein to the advice that the same component shouldn't have both layout and business logic in React, the same component shouldn't have both data fetch and layout. Separate concerns.","optimization#Optimization":"As apps scale, they start to make a lot of requests. Fortunately, the browser already does a lot of optimization for you. For example, with HTTP/2, multiple requests to the same origin can be batched, saving you time on establishing a connection. However, there are still multiple app-level optimizations that can improve the real and perceived performance of the application.","etags#ETags":"ETags are basically cache keys for web pages. For example, when you request an image, the server sends down a header saying here is a hash of the image. On subsequent requests, the client can send up the hash and say \"here is what I have, only send me the contents if it's different\".While primarily used for assets, you can also set ETags on API responses. For example, if you're displaying a text file to a user, you can set an ETag to prevent having to resend the file every time.","prefetching#Prefetching":"If you know you will soon need some data, you can request it ahead of time. For example, if you are showing a link to another page, you can fetch the data for that page when the link is rendered or scrolled into view.Most applications need some data before they can render anything (if nothing else, who is the current user? Are they signed in?). In server-rendered applications, this data can be inlined to the initial load with a script tag, but in single page apps, where the application is cached and queries the server for everything, any load begins with a second request for data.This request can slow down applications significantly, because, before anything shows up to the user:\nThe browser has to fetch the app\nParse and run the JavaScript\nMake the subsequent request for data\nRender the application\nIn cases where you know the browser will start with a request for data, you can hint this with prefetch:\nThis allows the browser to make this request ahead of time, and immediately pass the response to the JavaScript after it loads and makes the request.","optimistics#Optimistics":"While reads can usually be optimized with ETags and prefetching, writes are a little harder to optimize because you won't know the request you need to make until you need to make it.While you may not be able to optimize the performance of the request, you can make it appear faster. For example, if a user posts a comment you can show that comment as posted before the network request has completed. This strategy is called \"optimistics\" and is frequently implemented across networking libraries.","consistency#Consistency":"At the core of these optimizations is a desire to hide the network from the user (and make it appear as if all of the data is stored locally).One of the effects that breaks this illusion is when data updates in one place but not all the others. For example, if I update my profile picture, but some profile pictures are updated and others aren't (as new network responses are received). Consistency is a technique where you store entities received from the network in some global, reactive store (such as MobX or Recoil) and update the UI accordingly.For example, if you had a global dictionary of users (keyed by ID), you can update it any time you receive a new user, and return an handle to a consistent object.","long-lived-connections#Long lived connections":"Sometimes, data gets stale fast. For example, a chat app, where the person you're chatting with could message you at any moment. To keep data up to date, there are four general strategies:\nPolling: Query your server every N seconds asking for new data.\nLong polling: Poll, but rather than sending a \"no new data\" response immediately if there are no new messages, just keep the connection open and don't respond until either there is a message or you time out the requests (most browsers and servers impose a maximum limit on the time of a request).\nWebsockets: A technology that allows you to keep a connection alive between a client and a server and pass messages in between. This requires you to keep the server alive and write it to accept websockets.\nServer-sent events: Like websockets, but only in one direction, letting the server send multiple messages to the client via a long-lived connection (opened by the client).\nPush: A newer technology allowing the server to push messages to the client via a service worker.\nAll of these are viable strategies, and which one is right depends on the situation.","cors#CORS":"By default, websites can only make fetch requests to other URLs on their domain. However, cross-origin resource sharing (or CORS) is a protocol that allows servers to say that other domains can access them.CORS is set up via headers, and is usually implemented by a server library.Note: for non-GET requests, not having the right CORS headers doesn't prevent the client from making the request, it prevents it from reading the response. However, if you don't have CSRF protection (discussed below) a malicious client could still trigger your API.","security#Security":"The network is really the first time people think about security, and so I wanted to briefly touch on some best practices here. At first I debated making this a whole chapter, but for most people working in frontend codebases for the first time, someone else will have set this up for you.While there is a lot we could talk about in terms of SQL injection or HTTPS, I'm going to assume that you've been exposed to the backend and focus on frontend specific attacks.","xss-and-csp#XSS and CSP":"A classic attack is to try and inject HTML into user generated content that will be rendered. For example, imagine I post the following to my Facebook, and the site renders it as part of the site for my followers.\nThis would send me all of their cookies (including their API token), which I could use to login in as them.This is called cross-site scripting (or XSS), and is the reason why cookies can be set to be unreadable in JS.To further protect yourself, sites can define a content security policy (or CSP), which defines which scripts can run (for example, by totally banning inline scripts or requiring them to match a certain hash).","csrf#CSRF":"Well, if a malicious actor can't log in as you, perhaps they could trick you into doing something bad. One way to do that is with cross-site request forgery (CSRF), or making it appear as if you initiated an action that you didn't (at least knowingly). For example, I could write a page that looks like this:\nYou might click that link thinking you're about to sign in, and then you transfer $100,000 to me because your browser did initiate a request to your bank's API with your auth cookies!To protect against this, most sites implement \"CSRF tokens\" or random tokens stored in memory (or in a cookie) that can be used to prove that the requestor wasn't a random site. For example, I can store a JS-readable cookie that has a random value in it, and if the API request doesn't include that value, I can assume it was not made from my frontend (or \"forged\").","frames#Frames":"While CSRF protects unauthorized user requests, an old attack was to embed people's sites in iframes. Iframes allow you to embed other websites, and while useful for sharding out your site, they can also be used maliciously.For a contrived example, pretend I know who you bank with and can assume that you're signed in. I could construct a URL for the transfer page to transfer my bank account some amount of money from yours, and show you that page in an IFrame (which is scrolled to the exact position of the \"Transfer\" button) and put a transfer button on my site as part of some user-facing flow.For this reason, sites can now define a content security policy or header to prevent them from being iframed."}},"/profiling-and-testing":{"title":"Profiling and testing: Productionizing apps","data":{"":"As you get ready to deploy your application, you probably start to think about performance and stability.","profiling#Profiling":"Profilers are how we can reliably achieve and debug performance. Chrome devtools ships with a profiler that helps you debug slow parts of your JavaScript, and hopefully looks familiar to anyone who's previously worked with profilers or had to read flame charts.\nIn many ways, profiling is the same regardless of what language you're working in; however, something specific to rendering UI is profiling code that renders and rerenders UI. While the core technologies are the same, the implications and what you optimize are very different; for example, does it matter if Chrome takes a while to render something that's not visible until the user scrolls?(For webpages, which scroll vertically, content that is visible before scrolling is referred to as \"above the fold\" and content that needs to be scrolled to is referred to as \"below the fold\". This language is borrowed from newspapers, which are typically folded in half, and where the headlines want to be \"above the fold\".)","lighthouse#Lighthouse":"While the answer to that question depends on your specific application, there are a few metrics that the developer community has decided should matter generally:\nFirst contentful paint (FCP): Time until any content is rendered on the screen.\nLargest contentful paint (LCP): Time until the render that paints the most content above the fold.\nCumulative layout shift (CLS): A burst of renders that meaningfully move page content.\nFirst input delay (FID): The delay between a user's first interaction and its event handler running.\nInteraction to Next Paint (INP): Time from user interaction until the page rerenders.\nI'll caution you against over-indexing on these metrics. Over time they've evolved, and like most things in the JavaScript ecosystem \"over time\" is short. The \"most important\" metrics change every 2-4 years.Computing these metrics yourself can be tedious, and Chrome ships with Lighthouse: a tool that scores websites across a variety of metrics, including performance (as well as for SEO, accessibility, best practices, and other important things.) Lighthouse can be accessed directly from Chrome devtools.","react-devtools#React devtools":"Profiling is wonderful, but can be limiting when profiling applications using a framework: as suboptimal code is more likely to generate flamecharts pointing at React internals than the actual problem.Fortunately, React ships with its own profiler that can help you identify problematic code: React devtools.\nReact devtools are embedded within Chrome devtools and can inspect the React tree (much like the elements panel in Chrome devtools allows you to inspect the DOM).Additionally, React can expose hooks for devtools to be able to profile performance of React apps. Because these hooks add some overhead to the app, they are opt-in. There are three common builds of React:\nDevelopment: the version you build with when developing locally.\nProduction: the version that gets deployed to users.\nProfiling: Production with additional hooks for profiling.\nTypically, switching between these versions is handled by whatever scaffolder or meta-framework you used to generate your application, but can be manually defined.If you're using the development or profiling builds of React, React devtools can capture a profile and generate a timeline showing you the various tasks React was doing over time:\nReact devtools can also generate a flamechart of a render, and what caused certain components to rerender:","optimizations#Optimizations":"Because browser JavaScript is single-threaded, you want to make sure your render function doesn't take too long; for example, if you want your app to update in response to user input at 30 frames per second (video games tend to target 60fps) render can take a maximum of 33ms - time react needs to reconcile + commit (~16ms as a rule of thumb).Once you have identified any slow parts of your app, there are a few common tactics to speed them up.","memoizing-data#Memoizing data":"By far, the easiest thing to speed up is a single component that takes a long time to render. This is probably because that component's render function is doing some non-trivial compute; for a contrived example:\nEvery time this component renders, it will recompute the nth fibonacci number, even though it's previously computed it. The useMemo hook allows you to memoize expensive compute:\nuseMemo takes in a lambda whose return value to memoize, and an array of props. Whenever one of the values in the array changes, the value is recomputed (similar to the array of props for useEffect).","memoizing-components#Memoizing components":"Sometimes, you don't want to memoize data, but entire components. If you've poked around the React devtools profiler, you'll notice that every time a component rerenders, so do all of its children.This is the default behavior of React, and can lead to problems if state is held too high up in the tree; for example, imagine you have a very long list of items, stored as state in a parent component, and the user changes a single item. By default, React will re-render the entire list, but as the developer you know only the changed item needs to be rerendered. React provides memo to handle this case.\nWhen a component is wrapped in memo it will only rerender if its props change (defined as are no-longer pointer equal). In the event you're passing complex objects to your component (functions, objects, classes, anything where pointer equality is insufficient to determine equality), you can pass a second parameter to memo which takes in new props and old props and returns whether they're equal.","list-virtualization#List virtualization":"Sometimes simply rendering that many items in the browser (or having that many nodes in the DOM) will cause your app to be slow. This is commonly the case with really long lists (imagine a spreadsheet application viewing a sheet with 10,000 rows). In these cases, memoization won't solve the problem because the mere existence of those rows is causing a problem.The solution is to not render all of the rows, a technique known as list virtualization. In list virtualization, you compute which rows would be on screen (either because you measure the height of each row, or--even better--you know the height of each row ahead of time, for example, in the spreadsheet where all rows are the same height) and you only render those rows. For rows which are not rendered, you either replace them with a large empty box (that consumes equivalent space) or absolutely position all of the displayed rows at the location they would have been anyway.\nYou rarely have to implement list virtualization yourself, consider using react-virtualized and react-window.","testing#Testing":"As your app gets more complex, you will want to test it.","unit-tests#Unit tests":"Customarily, if you have any significant logic, you should break that out into its own package (for example, if you're writing a calendar app, I would expect a lot of the date manipulation logic to be its own package). As a package implementing pure logic (without UI), you can test it using any JavaScript testing framework. Some common options are Jest and Mocha (Mocha is a test runner typically used with Chai which provides syntactic sugar over assert). Code coverage can be computed with nyc.\nFor people that come from untyped / weakly typed languages (e.g. Python and Ruby) and are now working in a TypeScript codebase, a word of caution: I've noticed a heavy reliance on unit tests for things that can, or should, probably be typed instead. For example, there is no need to test that sum() will return a number, or even that zip() works, both of these can be fully checked by the type system.The type system is a really powerful way to reduce (or eliminate) the space you have to test; in the same way you don't rely on asserts for things you can test, and shouldn't rely on tests for things you could type.","integration-tests#Integration tests":"While logic should be pulled out of your app as much as it can be, there will still be components, and those components will still have logic (if nothing else, there are probably event handlers to test).react-testing-library works by actually rendering components, and providing utilities to query those components and interact with them (firing event handlers).\nBecause it actually renders components, it requires a DOM: the simplest way to run it is in the browser, which already has a DOM. You can also run it in Jest, which mocks the DOM automatically using jsdom and global-jsdom to define global variables for window and document. For any other environments, you'll need to mock the dom yourself.","end-to-end-tests#End-to-end tests":"While integration tests are great, they aren't bulletproof in the world of UI. For example, while you can still technically click a button, and that button may do what you expect, it's exceptionally hard to do if the button is off-screen or has a width of 0.For this reason, many frontend projects have some level of end-to-end testing: where they load their application in a literal browser, and attempt to interact with it (a simple example would be: find the X/Y coordinates of a button, move the mouse to that X/Y coordinates, and click). Because they rely on loading your application and browser state, end-to-end tests (E2E tests) can be notoriously flaky.Some common libraries are Cypress and Playwright.\nFrontend testing often inverts the traditional \"test pyramid\" - prioritizing end-to-end tests over unit tests. Frontend and backend codebases often differ in shape: backend tends to be deep and narrow (complex pieces with direct dependencies), while frontend tends to be wide and shallow (simple pieces with loose connections). This means frontend failures usually come from components interfering with each other, not internal bugs, and are better found with integration or end-to-end tests. (The exception is pure computational logic, which is typically isolated into packages and unit tested like backend code.)","visual-tests#Visual tests":"Lastly, when working with components where design and visual layout matter a lot (and definitely when testing a design system), it is common to do visual testing. In visual testing, you render a component, take a screenshot, and compare that screenshot against some stored value.As you might imagine, this can be incredibly fragile, and it's critical to mock out all data; if your component includes any networked-fetched data or relative time (\"N days since...\") it will likely fail. However, this type of testing can be useful to ensure you don't have regressions in critical components (for example, for a seemingly harmless CSS change causes all buttons to triple in size).There are plenty of services to help with visual testing, and some examples are BrowserStack and Percy.An alternative to this is snapshot testing where the rendered HTML is stored (instead of a screenshot).","reporting#Reporting":"Profiling and testing are great, but sometimes there are bugs that only happen in production.There are plenty of services that will help add observability to your frontend application (including Datadog, Senty, and LogRocket). But if you want to roll your own, consider web-vitals the technology behind Lighthouse and <Profiler> which gives you programmatic access to React renders."}},"/build-tooling":{"title":"Build tooling: More tools and more problems","data":{"":"The JavaScript ecosystem is a reminder that the web is held up by shoestrings and gum; it is this immense mess of technologies, all haphazardly thrown together, that somehow happens to work just enough to get your website online.\nI have no doubt that this heavily-customized, and poorly abstracted, tooling is one of the many things that scares away the casual developer from exploring frontend development. I hope to provide you with just enough context to see the forest among the trees, and let you resume your journey in frontend development.","writing-and-running-code#Writing and running code":"As the web has gotten more complex, JavaScript has turned from a simple scripting language--primarily embedded in HTML--to a full blown language. Its simple origins necessitated extensive tooling to keep up with the explosive adoption and ever-more-complex use-cases.","languages#Languages":"While JavaScript, the runtime target, has experienced incredible growth, people have done a lot to avoid writing JavaScript, the language. For example, CoffeeScript was pure syntactic sugar over JavaScript to emphasize the functional programming features of the language.Beyond syntax, as JavaScript codebases grew, they needed static typing:\nFlow: built by Facebook, one of the earliest attempts to add type annotations to JavaScript.\nTypeScript: the most popular way to add types to JavaScript. Built by Microsoft, it has become the defacto way to add types to JavaScript with support across the ecosystem.\nA second transformation of the language happened with React. As mentioned last chapter, a core innovation of React was .jsx files: allowing developers to write HTML in JavaScript. JSX used a transpiler to transform JSX files into JavaScript files by transforming the HTML-like syntax into JavaScript function calls. Specifically, the transpiler can take\n... and transform it into something like this:\nThere is also a tsx file type: TypeScript with HTML-like syntax.","compilers-and-transpilers#Compilers and transpilers":"Supporting those different languages are compilers and transpilers. In the world of frontend web development, the transpiler serves 4 key purposes:\nTypes: Supporting static typing, probably through TypeScript\nJSX: Supporting JSX / TSX\nSupporting different runtimes: these days, JavaScript runs everywhere--browsers (including different versions), the server, in desktop apps (via Electron), in CLI tools, etc. Those different runtimes require slightly different formats (more on that in the next section), and the compiler can abstract this away from the developer.\nPolyfills: Because different runtimes and different versions support different language features, the compiler can detect which features you need and inject any necessary polyfills.\nCommon compilers are:\nTSC: Ships with TypeScript. Compiles TypeScript to JavaScript.\nBabel: A pluggable compiler. Currently the most popular.\nSWC: A replacement for Babel written by Vercel intended to be faster.\nUse of these compilers and transpilers are not mutually exclusive. It's not uncommon to see projects use both TSC and babel in the same build step.","linters#Linters":"Lastly, sizable codebases want to ensure that developers are following common formatting. ESLint is the most popular linter, with many community-built plugins.While linters can catch many code-formatting bugs, Prettier is a very popular code formatter. It is typically used along-side Eslint.","build-targets#Build targets":"Because JavaScript runs everywhere, new platforms continue to create support for JavaScript. It is a self fufilling prophecy.","runtimes#Runtimes":"While JavaScript does have a language spec: there are different runtime engines (with partial or extended implementations of the language), different versions, and different global variables available at runtime; as a result, you need to know what platform you're building your JavaScript program for.The most common place to run JavaScript is the browser. Browsers consist of two parts: the UI (how you navigate to web pages) and the browser engine, the part that takes web pages and runs / renders them; while there are many browsers, there are only a few browser engines. Three key JS engines to be aware of are:\nChrome: supported by the V8 JavaScript engine, maintained by Google\nFirefox: supported by the SpiderMonkey JavaScript engine, maintained by Mozilla\nSafari: supported by the JavascriptCore engine (part of WebKit), maintained by Apple\nAs code running in the browser, any scripts have access to the document and window global variables.For a long time, those were the only platforms most developers JavaScript authored JavaScript for. Then Node came around and changed everything. Node took Chrome's JavaScript engine (V8) and created a set of APIs intended to run JavaScript outside the browser's sandbox. To this day, Node is the most popular way to author a JavaScript web server or run JavaScript scripts locally. It introduces a few global variables (including global, process, etc.) because the window and document APIs don't make sense when running outside of a web browser.Because users sometimes need to test or run code against different versions of node, nvm is a tool that lets users manage multiple node installs.While node is definitely still the most popular runtime for non-browser-based code, more recently we've seen the creation of new runtimes, including Deno and Bun, that try to improve upon the speed, size, and developer experience of node.For developers writing \"native\" (not browser based) applications, Electron is a platform built on top of Node and Chromium (the open source foundation of Chrome) that allows developers to write desktop apps in JavaScript. To enable that, it introduces a suite of APIs to access the native platform.And for developers writing mobile apps, React Native is the latest and most popular runtime allowing developers to write their mobile apps with web technologies. React Native used to use the platform's native JavaScript engine (V8 on Android and JavascriptCore on iOS), but more recently they've developed their own runtime, Hermes. Much like Electron, it introduces a handful of APIs for communicating with the host device. Older technologies that tried to make web technologies available to mobile developers include NativeScript and Apache Cordova.","module-systems#Module systems":"Due to its simple origins, JavaScript never had a good way to split out code across files. It wasn't intended for applications of that scale; as JavaScript broke out of the browser, this had to change, and many people rushed to create a solution. This led to many, competing solutions to the problem of \"how do I import one JavaScript file from another\".These module systems have mostly been pared down to 2:\nCommonJS (CJS): The most popular standard to date.\nECMAScript modules (ESM): The newer standard introduced as part of the JavaScript spec. This will eventually become the standard; it just takes time.\nOlder technologies that are no longer common are:\nAsynchronous module definition (AMD): Created for a polyfill that is no longer necessary.\nUniversal module definition (UMD): Created to unify the other module definition syntaxes. Relevant XKCD.\nIntroduced by Node, CommonJS allows developers to assign variables and functions to an automatically created module.exports object (e.g. module.exports.title = \"Hello, world!\"), and then import files via require(\"path/to/file.js\"). The contents of that file is the wrapped in a function and executed, returning the resultant value of module.exports. This object is a singleton (so requiring the object multiple times will return the same object).ECMAScript modules improve on this standard in a few key ways:\nExports are now done via an exports keyword (export const title = \"Hello, world\";)\nImports are done via an import keyword (import { title } from \"./path/to/file.js\")\nPromises can be awaited at the top level\nBecause ECMAScript modules are a superset of CJS modules, ESM files can import CJS, but not the other way around. Sometimes authors will denote this by naming ESM files as *.mjs, although I do not recommend this because ESM will become the standard after a few years.","bundlers#Bundlers":"While modules, predictably, became a very popular way to organize code, web browsers never added first party support for them. The result was a need for packagers: a way to take all of the modularized code and concatenate it into one file.The most popular packager is Webpack, which not only bundles, but has an extensive plugin ecosystem.That said, like everything else in this ecosystem, there are many alternatives. Some older ones include:\nBrowserify: early to the game, was very popular.\nMetro: used by React Native.\nMore recently, there have been a class of new entrants, all targeting the same problem: improving upon Webpack's (notably bad) performance:\nRollup\nESBuild\nVite\nUltimately, the bundler is a glorified version of cat, with a few extra features to ensure things like:\nDependencies are correctly ordered\nAny unreferenced code is removed (this is called \"tree shaking\")\nFiles are split up to optimize for browser caching (e.g. if you depend on a library that is unlikely to change, output a separate file so the browser can cache it across version bumps of your application)\nNode globals are shimmed to work in the browser (a common one is to replace process.env.FOO, the way you access the env variable FOO with whatever the value of FOO is at build time)\nMinifying code to save network bandwidth (for example, comments don't need to be sent to the browser and whitespace can be removed)\nWhen code is minified, most tools will generate source maps to help you symbolicate stack traces. Make sure not to ship your source maps to production or users will be able to decompile your code.","orchestrators#Orchestrators":"That's a lot of tools. Running them all in concert is difficult. The result is a set of tooling intended to help you coordinate all the other tools. Other languages and ecosystems use Make, some JavaScript projects do to, but as is customary here, we also have our own, bespoke, solutions.Grunt and, later, Gulp were introduced to help transform files. These days they're less frequent (as the packagers have subsumed much of this functionality), but still exist.","sharing-code-and-scripts#Sharing code and scripts":"The advent of modules and packages (more on that in a second) lowered the barrier to share and reuse others code, and led to an explosion of JavaScript libraries.","libraries-and-frameworks#Libraries and frameworks":"While modules certainly lowered the barrier to share, people have been sharing JavaScript forever. These days, most libraries can be found in the NPM package registry. And range from full fledged frameworks (you can install Electron that way) to libraries that add whitespace to strings.There are too many libraries to go through my favorites, so instead I'll try to reference them as they're relevant in later chapters. Three general pieces of wisdom about them are:\nWhile libraries are really easy to add and appear really friendly, make no mistake, you are introducing someone else's code to your codebase. That code could be buggy, built with a different set of constraints, or plainly insecure. Because JS developers are so quick to introduce packages, software supply chain security is especially difficult in JavaScript.\nSpeaking of different constraints, don't be afraid to peak into how a package is implemented. Far too often I hear developers say \"well I can't do that because the package does something close to what we need, but not exactly what we need\". Many packages are less than 100 lines, it's frequently easier and more maintainble to maintain that yourself than to hack around someone else's constraints.\nWhile many packages are written, far fewer are maintained. Part of the reason you'll hear me reference who authors which library is because I have far more faith that a tool built and used by Facebook will be maintained than one built by a no-name developer with no incentive to do so.","shims-and-polyfills#Shims and polyfills":"One important class of libraries are shims and polyfills. But before we talk about them, we need to talk about the governance of the web.The web standard is officially maintained by the W3C, a standalone group created to steward the protocols of the web; however, because browsers are maintained by various organizations, which APIs you can use depends on which parts of the spec the browser vendor has implemented. In addition,browser vendors (specifically Chrome and Safari) will implement APIs before they're standards as a way to serve the needs of their parent organizations (Google and Apple respectively) and as a way to push the web forward.CanIUse maintains a set of compatibility tables for various features across browser vendors and versions.To deal with the inconsistency of runtimes, websites use one of three strategies:\nBrowser detection: If you've ever seen the message \"Please open this site in Chrome or Firefox for the best experience\", you've experienced browser detection. The website is detecting which browser you're using, and gating the experience based on it, probably because the website requires some not-yet-widely-supported API. While common, this is broadly considered bad practice because it excludes niche browsers, excludes future browsers, and is unlikely to be updated once the new version of a currently-incompatible browser adds all the necessary APIs to support the site.\nFeature detection: The better version of browser detection is feature detection, which simply asks \"does the current browser support the specific feature I need\" (for example, if you're trying to use the window.querySelectorAll() function, you can test if window.querySelectorAll is a function; because in incompatible browsers it's not even defined). A popular library for this is Modernizr.\nPolyfills (aka Shims): The even better version of feature detection is to not only detect if the browser supports a feature, but to retrofit it when it doesn't. As I said, JavaScript is an incredibly flexible language and even lets you add new functions to base types (for example, you can add a method to the base array type). Polyfills will detect if a browser has an API, and if not, define it for you; for example, the .forEach() method was introduced on arrays, but before every browser had it, websites might include a piece of code that checked if forEach existed on the base array type, and if not, define it.","evolving-the-langauge#Evolving the langauge":"In addition to frameworks and polyfills, there are a handful of libraries dedicated to adding common utility functions to JavaScript. This is common in various languages; a popular example here is underscore.js.While the bareness of JavaScript can be disheartening to developers coming from more full-featured languages, I'll leave you on a positive note:As one who's been watching the language and browser runtime evolve, we are making strides. For example, when jQuery was popular, selecting elements in the DOM was difficult. The author of jQuery built Sizzle, a library that abstracted away selecting elements and let developers use CSS selectors instead. Since then, browsers have added native support for this pattern with document.querySelectorAll.And it doesn't stop there, we're watching the same thing play out with web components and shadow DOM: browsers are adding native support for the component architecture that frontend libraries popularized.","package-managers#Package managers":"Packaged with node came a tool called npm. npm created a standard way to share code. It specified a format of a zip archive with a package.json file at the root that specified any dependencies and the entrypoint to the code. It also provided an online regsitry to share these packages, that could easily be published to (using npm publish) or pulled from (using npm install PACKAGE_NAME).NPM is still the largest, and most common, registry; although some companies maintain private registries to share internal packages.That said, NPM is no longer the only package manager, and there are now other tools that help manage packages locally while still publish to and pulling from npm's online registry. PNPM is a tool developed as drop-in replacement for NPM, with one core advantage: it saves disk space by deduplicating shared packages across your machine.Yarn was developed by FB with a few key benefits over NPM:\nZero install: yarn stores a copy of dependencies as a zip file that you can commit. While you might wonder if committing dependencies is advisable, it speeds up CI and protects you from remote changes in the registry (in the past, people have removed versions of packages from NPM, breaking builds, and uploaded malicious versions that get updated with little auditability).\nPlug-n-play: Yarn introduced PNP as an opt-in way to save disk space, because zero install means that all packages are in zip files, why not override require() to simply reach into those zip files (which are unzipped in memory); this also saves the OS from having to page 100s-100,000s of tiny files into memory. While interesting in theory, and faster in practice, the ecosystem has not adopted it and getting tools like React Native, Webpack, or Electron to work with PNP is difficult. For this reason, I typically disable this.\nWorkspaces: discussed below.\nBecause of Facebook's support, and the corresponding features intended for company-wide monorepos, yarn is my preferred package manager.","workspaces-monorepos#Workspaces (monorepos)":"Packages were great, and soon people started putting many packages in a single repo. If memory serves, I think React was one of the earliest people to do this.NPM did not have great support for importing local packages (and certainly not for developing multiple local packages simultaneously). Yarn solved this through workspaces, and soon this became a common feature across various package managers.Along with supporting multiple local packages, developers needed a way to coordinate tasks across those packages (the most simple example being you should first build any dependencies of a package before you build the package itself). Two tools that came into existence were TurboRepo and Lerna. Because TurboRepo is supported by Vercel, it is my preferred tool.One edge case to call out with multiple local packages is Hoisting:For background, when you import a package in node, node climbs the directory structure checking in node_modules. For example, if I require package foo from /some/path/file.js, node will check the following locations, stopping when it finds a file.\n/some/path/node_modules/foo, and then\n/some/node_modules/foo, and then\n/node_modules/foo\nNow, imagine you have a repository with two workspaces, each which depend on react:\nIf A depends on B, compiling A will result in an artifact that contains two copies of react (as any code in workspace-a that references react will resolve to one react, and any code in workspace-b that references react will resolve to another react).One way to solve this in a workspace is to \"hoist\" react:\nNow both workspaces will resolve to the same react, and reference the same copy of react at runtime.If you find this confusing, it is, but it's something to be mindful of when working with workspaces.","scaffolders#Scaffolders":"If you had to set it all this tooling yourself, it could easily be a week of work. As a result, there are a handful of tools that help you scaffold new projects.The most common general tool here is Yeoman, which lets developers author custom project generators. There are also application-specific scaffolders, such as create-next-app, create-react-native-app, or HTML5 boilerplate."}},"/client-compute":{"title":"Compute: The universal virtual machine","data":{"":"As you build in a client-server architecture, one of the questions you'll inevitably have to face is whether to have a thick or thin client. In broad strokes:\nA thick client does as much as possible on the client (server sends data)\nA thin client does as little as possible on the client (server sends markup)\nThere is a full spectrum between these two, and there's merit to both.A thick client can immediately respond to updates, saves you server costs, and can be made to work offline. A thin client works great for compute constrained devices (e.g. mobile), can be updated instantly (servers receive updates faster than clients), and keeps source code secret.Over the years we've seen the pendulum swing back and forth between the two, largely in response to:\nIncreasing client capabilities: the browser being able to power common frontend apps like email or chat is what led to the rise of frontend frameworks in the first place\nIncreasingly compute intensive applications: for example, most AI cannot yet run in the browser\nDecreasing compute on the client: mobile gave way to a whole new wave of thin clients... and if smart watches start having web browsers, I imagine we'll see the same cycle repeat itself","app-capabilities#App capabilities":"In recent years, we've seen progressively thicker clients, supported by a new generation of APIs giving web apps more capabilities that had previously been restricted to native apps.","offline#Offline":"\"Web app\" and \"online\" frequently go hand-in-hand, but in recent years applications have started to push those limits. Today, service workers are the standard way to implement offline in your application.Service workers are written as separate JavaScript / TypeScript files and intercept network requests; this:\nAllows you to serve network requests from a cache, even if the device is offline,\nWithout having to change how the original webapp is written.\nThe structure of the service worker script is a list of event handlers. Two core events are install (that the service worker is being installed and should cache data) and fetch (a request from the app was made).\nIf you're using TypeScript, you can prefix the file with the following to get correct types:\nService workers can require a lot of setup, and Workbox is a library from the Chrome team to make it easier.","progressive-web-apps#Progressive web apps":"The second largest user-facing difference between a website and an application is that an application is \"installed\" on the device (meaning that it is available outside the browser, offline, and alongside other native applications). Progressive web apps (PWAs) allow users to install your webapps as apps.A PWA works by implementing a service worker and providing a separate manifest.json file that tells the browser about what resources it will need to run, along with metadata like name and icon. For example:\nAnd is referenced by the webpage by adding a custom link tag:\nThe list of required fields in a PWA manifest can be found here and, the complete list can be found here.","device-apis#Device APIs":"Today, progressive web apps (and web pages generally) can do so much; some examples include:\nRead files on disk\nAccess the fingerprint reader\nRecord the screen\nUse bluetooth\n...and a lot more","compute-capabilities#Compute capabilities":"Even with the capabilities of native apps, there's always been a gap between the performance of web apps and native apps. At the heart of that is a restriction that web apps need to be able to run insecure code, and sandboxing has historically added a noticeable overhead.That said, advances in compute, compilers, and languages have started to bridge that gap.","threads#Threads":"Like many interpreted languages, all JavaScript is single threaded.And like many UI frameworks (e.g. iOS and Android), only the main thread (or JavaScript running on the page) can read or write to the DOM, to prevent race conditions. And, to take that a step further, running JavaScript in the main thread blocks rendering (because the rendering logic and JS share a thread).When writing performance-sensitive or compute-intensive applications, this can be limiting. However, modern browsers let you overcome this by creating \"workers\": JS files that run in separate threads.Service workers, described above, are actually a subclass of webworkers, and like service workers, webworkers are structured as lists of event handlers. Communication to the main thread is done through \"message passing\", a method of cross-thread communication based on events.For example, here is a script that would spin up a worker to get the nth number in the fibonacci sequence:\nWithin the worker:\nNote: both of these are using the shorthand way to attach event handlers (onmessage), you can also write:","arraybuffers#ArrayBuffers":"ArrayBuffers are a way to access raw blocks of memory. For compute intensive applications, or applications that need to load binary data into memory, they provide that access.Memory can be shared across workers by using SharedArrayBuffers.","wasm#WASM":"The last technological arc to highlight is the compilation of traditionally native languages into JavaScript, allowing near-native performance in the browser, despite being sandboxed.It started with ASM.js and Emscripten: ASM.js was a subset of JavaScript intended as a compile target, and Emscripten was a backend for LLVM (a very common compiler with support for C, C++, ObjC, etc.). Emscripten could compile native code into ASM.js and even render graphics APIs directly to the screen via Canvas (JavaScript’s realtime drawing APIs).This made for interesting technical demos, but became very real with WASM (or WebAssembly), a browser-supported compile target for the web that was (1) safe, and (2) directly transformable into native bytecode. This made it much faster than anything interpreted; some of the early benchmarks of WASM showed that it was only 2x slower than native! While this might seem like a high number, imagine being able to run PhotoShop in your browser with only 2x overhead compared running native... that’s really fast.For a while, this just resulted in cool demos:\nDOOM 3\nGoogle Earth\nWindows 95\nHowever, we're starting to see some real production use cases:\nFigma uses it to power their editor (source)\nGoogle sheets uses it to power their formula (source)\nNotion uses it to power their clientside cache (source)","the-universal-virtual-machine#The universal virtual machine":"The web platform is the closest we've ever been to a universal app runtime: a sandboxed render engine and scripting environment that runs on virtually every device: your computer, phone, watch, Tesla, fridge, and IoT devices all run JS. For something between satire and reality, The Birth and Death of JavaScript is a funny talk that becomes more real every day."}},"/css":{"title":"CSS: The style of web pages","data":{"":"HTML was great for academic documents, but not great for marketing materials and definitely not great for full applications. People wanted a way to style their documents, and that is how we got CSS.Building on our earlier example, let's create a folder with two documents:\nThis is the same as above, but with an added <link> tag (which is just telling the browser the address it can request to find an associated CSS file; because the address doesn't begin with a / it's presumed to be relative to the HTML file). And:\nThis is a CSS file! It says that all paragraph tags, p, should have a text color of red.You can open that HTML file to see it with the style applied. And, like our HTML example, we can continue to experiment using CodeSandbox:","selectors#Selectors":"CSS is all about selecting elements and modifying their properties. CSS files are structured as lists of these rules, which use a selector to specify element(s) the rule applies to and lists properties to apply to those matched elements.\nThere are three main types of selectors:\nfoo: this matches all elements of the tag foo (for example, <foo />)\n#foo: this matches the element with the attribute id=\"foo\". Every ID must be unique.\n.foo: this matches all elements which include the attribute class=\"foo\". Unlike IDs, there can be many elements with the same class; there can also be multiple classes per element; for example, an element with class=\"foo bar\" will match both .foo and .bar.\nThere are also attribute selectors, which match elements based on the value of an attribute, for example [type=\"text\"] matches all tags with the type attribute set to text.","composing-selectors#Composing selectors":"Selectors can also be combined:\nCommas allow either selector to match (e.g. #foo, #bar applies to either #foo or #bar)\nSelectors can be concatenated so ALL selectors must match (e.g. p#foo.bar matches any p tags with the ID foo and the class bar)\nSpaces match descendents (e.g. .foo .bar matches any element with class bar that is a descendent of an element with class foo)\nCombinators can be used to build more complicated relationships (e.g. .foo > .bar matches any element with class bar that is a direct descendent of an element with class foo)","specificity#Specificity":"If two different selectors apply to an element:\nthe properties in the selector with the most IDs in it wins (#foo has 1 ID but #foo #bar has two IDs);\nif both selectors have the same number of IDs, the properties in the selector with the most classes wins;\nif both selectors have the same number of classes, the properties in the selector with the most tags wins;\nif both selectors have the same number of tags, the properties in the selector defined later in the file wins.\nThis is called specificity.CSS rules can be thought of as applying from lowest specificity upwards. So, if a rule sets the text color to red, and no higher specificity rule overrides it (or there is no higher specificity rule), the text color will still be red. (This is where the cascading of Cascading Style Sheets comes from).","pseudo-selectors#Pseudo-selectors":"Selectors can also match states. These selectors are prefixed with a colon. For example, .foo:hover matches elements with class .foo when the mouse hovers over them:","properties#Properties":"As I said, CSS is all about selecting elements and modifying their properties. Properties are all of the form property-name colon property-value (which sometimes includes a unit). For example,\nwidth: is the property\n200px is the value (px is the unit, meaning pixels)\nValues can either be:\nEnums (e.g. text-decoration: underline): which are property specific.\nMeasurements (e.g. width: 200px): that take the form of pixels (px), inches (in), as a percent of the screen’s height (vh), or something else entirely. Zero is always unitless (because it’s always the same).\nPaths to other files (e.g. background-image: url(./file.png)): the value is a filepath relative to the CSS file, and while url() may look like a function, it is just telling CSS the type of the value. The path can either be quoted or unquoted (like bash parameters, the quotes are only important if there is a space).\nColors (e.g. color: red): which either take the form of names (e.g. red) or as triplets of red, green, and blue values (RGB). If you're new to digital graphics, an online color picker is a good way to build intuition mapping colors to RGB (rgb(255, 0, 0)) or hex(adecimal) values (#FF0000). (Note: there are other ways to specify colors, but they are less common.)\nWith CSS properties, you can do everything from change the cursor to full 3d transforms. While I can't cover everything CSS can do, some basics you might encounter are:\nText color: color: red;\nText size: font-size: 12px;\nBold text: font-weight: bold;\nBackground color: background-color: red;","layout#Layout":"One particularly important set of properties are those that effect the size and position of your elements.By default, divs are arranged in one column from the top of the page to the bottom and have the height of their contents. This is one of three default layout kinds:\nblock: the element takes up a whole row (e.g. <div>)\ninline: a selection of text, the element takes up no space beyond the inner content (e.g. <span>)\ninline-block: something that has a height and width, but doesn't need a full row to itself (e.g. <img>)\nYou can override the layout kind via the display property. For example, normally divs don’t show up next to each other, but by changing their display to inline-block we can get the browser to lay them out next to each other.","sizing-the-box-model#Sizing: the box model":"As for how these elements are sized, no CSS tutorial would be complete without a discussion of the box model. The box model is a framework for how much space each element takes.Each element is modeled as four concentric rectangles (or boxes):\nContent: the innermost box that contains the children of the element\nPadding: white space that includes the background\nBorder: a line around the padding\nMargin: space outside the border separating the element from adjacent elements.\nFor each rectangle, you can define all sides at once (padding; 16px), each side individually (padding-left: 16px), or each side individually using a shorthand (padding: 16px 12px 8px 4px defines the top as 16px, right as 12px, bottom as 8px, and left as 4px).The height and width of the content default to whatever height and width the children require to be laid out, but can be explicitly set via the height and width properties (e.g. height: 100px). In addition to specifying a height and width, you can also constrain them using max-height, max-width, min-width, and min-height. For example, an element with the example below will be as wide as possible, but not more than 800px:\nWhile height was intended to define height of the content, many developers assume it refers to height of the element (including the height of contents, padding, and border). For example, a developer that assigns a box a height of 16px and a padding of 4px, might be confused when the height of the element is 24px instead of 16px (4px top padding + 16px height + 4px bottom padding).This confusion was sufficiently widespread (as was the desire to specify the overall height of the element) that css introduced the box-sizing property to allow developers to toggle whether height refers to the height of the content or the height of the element: box-sizing: border-box redefines height as content height + padding height + border height (the same applies to width).So far, we haven't talked much about margin, a word of caution there: many developers shy away from margin because doesn't always behave intuitively. Specifically: if you have two div's on top of each other with a margin of 10px, the total space between them will only be 10px (as both are at least 10px away from their neighbors). This is called margin collapsing.","flex-and-grid#Flex and Grid":"While blocks and inline-blocks worked well for documents, they reached their limits with applications. For a long time people hacked <tables>'s for layout, then <div>'s became popular, but ultimately application UIs demanded something more. As a result, two layouts were introduced: flexbox and grid, which both let you define elements flexibly and in relation to other elements.\nWhile the full APIs are probably more complicated than we have space to get into, there are wonderful tutorials:\nFlexbox: https://flexboxfroggy.com/\nGrid: https://cssgridgarden.com/","positioning#Positioning":"Lastly, sometimes you want to position an element directly (rather than having the browser lay it out for you). In this case, you can position an element relative to:\nits parent: using position: absolute\nthe browser window: using position: fixed","browser-defaults#Browser defaults":"If you don't define a property, the browser will fall back to its default; different tags have different defaults (for example, on Chrome, the <body> has a default padding of 8px). These defaults are not consistent across browsers. As a result, developers will frequently reset these properties themselves, and it is common to see declarations like the below in boilerplate projects:\nTo standardize CSS defaults across browsers, the idea of a \"CSS Reset\" was introduced:a stylesheet that overrides browser defaults. One of the more popular resets is normalize.css.","devtools#Devtools":"You might be wondering, is that all it really is? Is every web page written this way? Yes, and I can prove it. If you're using Chrome, right click on this page and click “Inspect” you’ll open up your browser’s developer tools panel (a similar concept exists in most browsers, but I'll be focusing on Chrome's).The developer tools panel includes a variety of tools, but if you open “Elements” you’ll see the full HTML of the webpage, starting with the <html> tag (technically this is showing you the DOM, but more on that later). You can select an element to see its CSS and box model.\nYou can read more about the developer tools panel here; the rest of the tools primarily help you debug any JavaScript running alongside the page, and we’ll get to that in the next chapter.","advanced#Advanced":"There is no way to cover all of CSS in one chapter. There are simply too many properties. Even people who have been working with CSS for years still discover new properties (partially because new properties are also introduced regularly).Hopefully, I've given you enough of a foundation to understand any new properties you run into. To that end, there are a few remaining concepts that could benefit from additional explanation. Here is a whirlwind tour.","media-queries#Media queries":"Media queries allow you to apply different CSS properties based on properties of the medium (most commonly, browser width or color scheme). This lets you have different designs for, for example, mobile vs desktop or light mode vs dark mode.","variables#Variables":"CSS has gotten more advanced over the years, and you can now specify properties that compose into other properties.\nYou can also compute things with calc (e.g. width: calc(80% - 10px). calc certainly has its place, but in general, I see first-time CSS developers overuse it. Calc is rarely necessary and leads to hard-to-understand code--that can be less performant--compared to using the browser's native layout technologies (flex or grid).","animations#Animations":"There are two types of animations you can define in CSS. Transitions, which define how to change between different values of a property:\nAnimations, which animate an object:\nAnimations rely on \"keyframes\": a concept borrowed from animation, you specify the properties at specific points, and let the runtime interpolate the middle state (for example, if you know that a box starts at 10px wide and ends at 20px wide, you can infer that half way through that animation, the box should be 15px wide).","pseudo-elements#Pseudo-elements":"Selectors can also create elements. For example, .foo::before will create an element within all elements with class foo but before their children.Yes this is weird; an example of when you might use it is to add a bullet point before items in a bullet point list."}},"/javascript":{"title":"JavaScript: The function of web pages","data":{"":"All UI pretty much boils down to this:\nDraw something on the screen\nListen to and react to user events (clicks, hovers, swipes, etc.) or global events (time changed, window resized, wifi disabled)\nJavaScript was developed in response to that second requirement; it was famously “developed in 5 days” as a way to add limited interactivity to documents: for example, to power dropdown menus.","the-language#The language":"Despite the name, the language shares very little with Java, and is instead based on the ECMAscript standard (a scripting language specification). Because of its rapid adoption and growth from a small scripting language to a full-blown application framework, JavaScript has a fair bit of bloat and plenty of language quirks that should be avoided.\nFor a good highlight-reel of those quirks, check out the WAT of JavaScript.\nHowever, quirks aside, it is an incredibly powerful programming language. In fact, your browser has a full JavaScript REPL embedded in it: open up devtools and click on the “Console” tab and type:\nWhen you click enter, the browser will evaluate that line and print “Hello, world!”. To take it a step further, you can copy the following to print your name!\nFor a crash course on the syntax of JavaScript, check out Learn X in Y.","the-browser-runtime#The browser runtime":"In the context of web pages, JavaScript is either included as a referenced file (same way CSS is included):\nOr directly written inline:\nBy default, when the browser is parsing the HTML, if it encounters a script tag, it will stop, load, parse, and run the JavaScript before it resumes parsing the HTML. This is very rarely desired—as you almost always want to display SOMETHING to the user before you start loading a script—so you’ll either see script tags included at the bottom of the body (after the main content has been parsed and displayed) or with an async attribute (e.g. <script src=\"...\" async />) which does the same thing.","the-dom#The DOM":"JavaScript is loaded alongside the webpage, and the runtime provides hooks into the browser’s in-memory model of the page: called the “document object model” or “DOM”. The DOM lets JavaScript listen for events and modify the page in response.Much like we did with HTML or CSS, we can experiment using CodeSandbox. For example, I can query for all the paragraph tags using:\nAnd I can modify, or remove, those matching elements:","events#Events":"As I said before, every UI language needs a way to respond to user events. In JavaScript, this takes the form of explicit event listeners that you can attach. For example, I can add an event listener for click events:\nBecause components are nested, events may occur on multiple components:\nYou may have noticed that the parent event happens AFTER the child event. by default, events bubble from child to parent up the document tree.By selecting the element in your browser’s developer tools, you can see any event handlers attached to it:\nAnd if you go to the source panel, you can even set a breakpoint on it.In these examples, I've mostly focused on the click event, but there are many, many event types available. Some examples include:\nmouse events\ndrag and drop events\nanimation events (animation started, completed)\nwindow events (scroll, resize)\ngyroscope and accelerometer events\nnetwork events (went online / offline)\n...and hundreds more","html5-apis#HTML5 APIs":"With the building blocks of HTML, CSS, and JavaScript, the web changed very quickly: JavaScript didn’t stay a scripting language intended to open and close dropdowns for long; developers got increasingly ambitious with what web applications could do; and APIs were added to enable increasingly more native experiences; specifically:\nXHR: enabling webpages to programmatically query the network for additional data. (These days, the fetch API is more common.)\nHTML5: an updated specification for HTML, adding APIs targeted at full application development such as offline, history, geolocation, file reading, image rendering, etc.\nFor a full list of JavaScript APIs, check out MDN.","frontend-frameworks#Frontend frameworks":"Alongside the new APIs and browser-based applications (or perhaps powering the browser-based applications) came a suite of libraries built at targeting frontend.","wave-1-utilities#Wave 1: Utilities":"The first wave of popular frontend frameworks came about in the 2000s and provided utilities to decorate static documents rendered on the server with interactivity. They general shape was \"select element\" and \"do something to it\" (at this point, you could not select elements with CSS selectors natively). Alongside that core functionality, they provided shims to simplify various browser tasks, such as requesting data from the network (something that was difficult at the time).\nExamples include: Mootools, Prototype, and jQuery.","wave-2-data-binding#Wave 2: Data binding":"The second wave came about in the late 2000s / early 2010s and made it easier to bind data to HTML. Unlike the first wave, which treated the HTML as the source of truth for data, this wave assumed that JavaScript was the source of truth for data (treating JavaScript as a first-class citizen, rather than a progressive enhancement); these frameworks made it easy to store state in JavaScript, interpolate that state into their HTML, and modify that state in response to HTML events.\nExamples include: Backbone, Angular 1.0, Ember, and Knockout.","wave-3-components#Wave 3: Components":"The third wave further abstracted UI into components: bundles of structure, style, and function creating reusable UI concepts (a menu, table row, or form input).\nExamples include: React, Angular 2.0, Svelte, Vue, and Solid.js.A key innovation of React was JSX, a superset of JavaScript that allowed developers to write HTML-like syntax in JavaScript files. This language could be transpiled into JavaScript (with a object-based representation of the inlined HTML). We'll cover this more later.","wave-4-fullstack#Wave 4: Fullstack":"More recently, we've seen a fourth wave begin to emerge. Technologies like Next.js take advantage of the fact that JavaScript now powers both the client and server for many sites. By using Next.js, you can write React code that renders on the server, and keeps the client up-to-date.While this wave is still early, examples include: Next.js, Remix, and Astro.I will call out that these waves are fuzzy, and the idea of writing JavaScript that was shared between client and server started much earlier with Meteor."}},"/state":{"title":"State: Separating logic and render","data":{"":"As you scale your application, you will inevitably need two parts of your app, which are not near each other visually or in the DOM, need to access the same data; for example, consider a code editor with a file tree on the left. Opening a file needs to update the main window and also the file tree (to highlight the file).The common response to this is to \"elevate\" the state to the nearest shared ancestor, and thread the state, and its setter, down to both components via props.","the-default-prop-drilling#The default: prop drilling":"Do this enough, and you'll find your codebase looking like this:\nThis quickly becomes hard to manage, and slows down development of your application. Every piece of application-level state now needs to be created at the top and threaded through N-many levels of your tree.This is called prop drilling, and is the sign that your application has outgrown basic state management.","event-delegation#Event delegation":"As a word of caution, many people find themselves prop drilling because they forget that React renders to HTML, and don't leverage the DOM. For example, imagine you have an email inbox with each email as a row, and every row has a button to select the row (for bulk operations) and one to delete the row. At first, you might imagine that you need to pass props to select and delete to each row.\nHowever, this doesn't leverage the fact that in HTML all events traverse the entire tree.Instead of handling the onClick event inside of each row, we can instead handle it at the table level by attaching a data-id attribute to every email.\nAnd extracting it from the \"target\" of the event (the inner most element):","architecture#Architecture":"That said, not all prop drilling can be solved with event delegation (and sometimes event delegation can make your code messier or create spooky action at a distance). Another way to reduce prop drilling is to rearchitect your application to construct the components that need state closer in the tree to where that state is defined.","composition#Composition":"Imagine we're building an app, and in the top right there is a dropdown that lets the user:\nSwitch accounts\nGo to the settings page\nSign out\nThe state of which accounts the user can switch to, the current page, and sign in status are all stored at the root. One way, and probably the default way, to build this is to drill all of the props:\nHowever, this makes the code brittle to changes, as any new prop will now need to be added to multiple layers of components; another option is to pass the children elements into the Dropdown:\nAnd this pattern can extend to the header:\nThe advantage of this is that if the account switcher needs new props, or you want to add another item to the dropdown, there is no need to drill props. This pattern is called composition over inheritance, and is recommended by the React docs themselves.Here is a blog post I really like on the topic.","render-props#Render props":"Composition works great, but it breaks down when you have a component that needs props from multiple layers in the component tree. For example, consider the same dropdown case, but you want to close the dropdown menu if the user changes accounts--well now we have a problem: the state of whether the dropdown is opened is handled within the <Dropdown> component, but all the other state is at the root.We can solve this with a render prop: rather than passing children, pass a function that returns children:","context#Context":"If neither of those are possible, React does have a way to pass data to arbitrarily deep descendents: context.Context is defined globally (with a default):\nSet somewhere in the tree:\nAnd can be read in any descendent:\nIf a component tries to read context, and no ancestor set it, the context call will get back the default.","an-implicit-dependency#An implicit dependency":"While context seems magical, I would strongly caution against using it for any value that's not truly global in your app. The reason is that it's an implicit, and unmarked, dependency: imagine a function that before you call it you had to set a specific global variable... if that's not somehow marked on the function, it's likely to be forgotten as that code is refactored or reused. The same is true of context.Imagine you're developing an online shopping website:\nYou've written the shopping cart component that has an item component that takes in a product name, quantity, and price and displays it to the user.\nLater on, someone decides that each row in the shopping cart should allow users to right click to remove the item from the shopping cart. Not wanting to drill another method, you decide that each item should reach into a shopping cart context to remove itself from the cart.\nSometime later, a different developer is working on the past orders page, likes the display of the \"list of items\" component from the shopping cart, and reuses it (unaware of the remove from cart behavior).\nUnfortunately, because neither the ShoppingCartListOfItems component or the ShoppingCartItem component obviously depended on the shopping cart context, when a user right clicks to remove an item not in the shopping cart, at best it will do nothing and at worst it will crash. Had those components declared their dependencies, this wouldn't have happened.Now one could argue that the developer should have fully audited the component before they chose to reuse it, but that becomes prohibitively expensive as the app scales. Imagine you're making a food ordering app, and there is a map view to see restaurants, and when you click on a restaurant a carousel of pictures pops up, and if you click a picture it adds it to the current order.Now someone decides to reuse that map to show previous pickup orders, unaware that if the user were to click on a different restaurant, and then click on an image in the popped up carousel it would crash the app because there is no \"current order\" context.","extracting-state#Extracting state":"With all this complexity, you might be wondering: \"well, why store my state in React at all?\"The short version is because React needs to know when state changes so it can rerender. If you were to store all of your state in a global variable and just tell the root-most React element to rerender, React would have no idea which child, or memoized, components to rerender.If you were particularly ambitious you might ask, \"well, can I keep track of which components need to be rerendered and then tell that to React\", and the answer is yes and there are libraries that will do that for you.","external-state-stores#External state stores":"These libraries are called external state stores, and were created in response to the issue of having complex application state used at many levels in the application's component tree.The most popular libraries here are:\nRedux: Probably the most popular state manager (and one of the first); it was intended as a general purpose library (and can be used without) React, but has solid support with custom React hooks.\nRecoil: Second to Redux, this is a state manager focused solely on React.\nZustand: The lightest-weight option, makes it very easy to define small state stores.\nMobX: Ultra-focused on performance, but somewhat of a boilerplate-heavy syntax; it was introduced to me as the \"enterprise option\", and in many ways I agree with that analysis.\nUnlike other technologies in the React ecosystem, I don't think there is a clear winner here.All of these libraries have:\nsome way to define state\nsome way to read state\nsome way to set state\nHere is an example of what working with one of these libraries, in this case MobX, is like:\nThat said, you don't only have to store MobX globally, you can also store it locally:\nThis is better than prop drilling because you can wrap all of your states in one object; in many ways, this is a type-safe context, as you can explicitly declare your components dependencies and the component only rerenders if the specific properties of the state that it read change.","prefer-local-state#Prefer local state":"I'll caution against is that as you have a solution for a global state store, you might be tempted to put ALL of your state in there. Before you clutter your state store, two questions to ask are:\nDoes this state really need to be read from two different places in the tree (if you can, keep it local)?\nIs there another way to refactor this to avoid global state (composition, render props)?\nOne thing I would caution you against is reading text input values directly from a global state store:\nSetting values in all of the external state managers may not be instant (they all have some overhead), and if React rerenders before it's been state the user may experience jumps or flickers while typing.","react-is-not-mvc#React is not MVC":"One thing I'll say is that as people start to run into issues of state management and prop drilling, I've seen developers turn to other, older patterns such as MVC or MVVM. React is not cleanly MVC or MVVM, and--in my experience--forcing your code to conform to either of those patterns is going to result in less-React-y code with heavy boilerplate and frustrating self-imposed restrictions."}}}